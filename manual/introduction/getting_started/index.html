<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.lunasdk.org/manual/introduction/getting_started/" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Getting Started - Luna SDK Docs</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Getting Started";
        var mkdocs_page_input_path = "manual\\introduction\\getting_started\\index.md";
        var mkdocs_page_url = "/manual/introduction/getting_started/";
      </script>
    
    <script src="../../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> Luna SDK Docs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../license/">License</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../roadmap/">Roadmap</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Manual</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Introduction</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../">Introduction</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Getting Started</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#prerequisites">Prerequisites</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-the-program">Creating the program</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#program-structure">Program structure</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#window-creation-and-event-handling">Window creation and event handling</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#fetching-graphics-device">Fetching graphics device</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-command-queue-and-command-buffer">Creating command queue and command buffer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-swap-chain">Creating swap chain</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-descriptor-set-layout-and-descriptor-set">Creating descriptor set layout and descriptor set</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compiling-shaders">Compiling shaders</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-shader-input-layout-and-pipeline-state">Creating shader input layout and pipeline state</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-render-and-depth-textures">Creating render and depth textures</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-buffers">Creating buffers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#loading-image-from-file">Loading image from file</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#set-up-descriptor-set">Set up descriptor set</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#camera-control">Camera control</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#resource-barriers">Resource barriers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#drawing-the-box">Drawing the box</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#presenting-the-render-result">Presenting the render result</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reference-code-for-maincpp">Reference code for main.cpp</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reference-code-for-xmakelua">Reference code for xmake.lua</a>
    </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Basics</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/">Basics</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/coding_convention/">Coding Convention</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/initialization_and_shutdown/">Initialization and Shutdown</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/basic_types/">Basic Types</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/strings/">Strings</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/memory_management/">Memory Management</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/modules/">Modules</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/variants/">Variants</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/type_system/">Type System</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/serialization_and_deserialization/">Serialization and Deserialization</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/boxed_objects/">Boxed Objects</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/interfaces/">Interfaces</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/error_handling/">Error Handling</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/assertions/">Assertions</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/file_management/">File Management</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/thread_and_synchronization_objects/">Thread and Synchronization Objects</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/time/">Time</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/logs/">Logs</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../basics/math_library/">Math Library</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">Luna SDK Docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Manual &raquo;</li>
          <li>Introduction &raquo;</li>
      <li>Getting Started</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="getting-started">Getting Started</h1>
<p>Welcome to Luna SDK. In this article, we will guide you to Luna SDK by creating a simple program that draws one textured 3D cube on the screen. At the end of this article, you will have a basic understanding of using Luna SDK to create a simple graphic program, and can start to explore more advanced features provided by Luna SDK.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>In this article, we assume that you have the basic knowledge of C++ programming and graphics programming (like using D3D11, D3D12 or OpenGL). You should also correctly setup Luna SDK and developing environments using the instructions provided in <code>README.md</code> of the project.</p>
<h2 id="creating-the-program">Creating the program</h2>
<p>The first thing to do is to create an binary target for our demo program, so that XMake build system can correctly build our program. To create a new program, create a new folder in the <code>{LUNA_ROOT_DIR}/Programs</code> directory, and name it <code>DemoApp</code>. In this folder, create a new Lua script file called <code>xmake.lua</code>, and fill its content with the following text:</p>
<pre><code class="language-lua">target(&quot;DemoApp&quot;)
    set_luna_sdk_program()
    add_files(&quot;**.cpp&quot;)
    add_deps(&quot;Runtime&quot;, &quot;Window&quot;, &quot;RHI&quot;, &quot;ShaderCompiler&quot;, &quot;Image&quot;)
target_end()
</code></pre>
<p><code>target</code> and <code>target_end</code> enclose a <em>target scope</em>, where all target definitions are specified. <code>set_luna_sdk_program</code> tells XMake that we are defining one Luna SDK program, this will let XMake set the target kind to "binary" and import all SDK options for the program. <code>add_files("**.cpp")</code> tells XMake to add all CPP files in the current directory and all subdirectories to the this target. <code>add_deps</code> lists all libraries that this program links to, in our example, we need to link to the SDK runtime (<code>Runtime</code>), the window module (<code>Window</code>) , the Graphics API module (<code>RHI</code>), the shader compiler module (<code>ShaderCompiler</code>) and the image file module (<code>Image</code>). If you got unresolved external symbol errors when compiling, make sure you already link correct libraries.</p>
<p>Then we need to create source CPP files for our program. Since out demo program is simple, we only create one "main.cpp" file to host all source codes. After this, the <code>DemoApp</code> directory should looks like this:</p>
<pre><code>DemoApp
|- xmake.lua
|- main.cpp
</code></pre>
<p>The last thing is to add one line in the end of <code>{LUNA_ROOT_DIR}/Programs/xmake.lua</code> to tell XMake to add our program in the solution:</p>
<pre><code class="language-lua">includes(&quot;DemoApp&quot;)
</code></pre>
<p>Well done, now every is set up and we can start to program our first Luna SDK program!</p>
<h2 id="program-structure">Program structure</h2>
<p>Next, fills <code>main.cpp</code> with the following initial content. As we go further, we will add more properties and methods to our <code>DemoApp</code> structure, while remaining the rest part unchanged.</p>
<pre><code class="language-c++">#include &lt;Runtime/Runtime.hpp&gt;
#include &lt;Runtime/Module.hpp&gt;
#include &lt;Runtime/Debug.hpp&gt;
using namespace Luna;
struct DemoApp
{
    RV init();
    RV update();
    bool is_closed();
};
DemoApp* g_app = nullptr;
RV DemoApp::init()
{
    return ok;
}
RV DemoApp::update()
{
    return ok;
}
bool DemoApp::is_closed()
{
    return false;
}
RV run_app()
{
    auto result = init_modules();
    if(failed(result)) return result;
    g_app = memnew&lt;DemoApp&gt;();
    result = g_app-&gt;init();
    if(failed(result)) return result;
    while(!g_app-&gt;is_closed())
    {
        result = g_app-&gt;update();
        if(failed(result)) return result;
    }
    return ok;
}
int main()
{
    bool initialized = Luna::init();
    if(!initialized) return -1;
    RV result = run_app();
    if(failed(result)) debug_printf(explain(result.errcode()));
    if(g_app) memdelete(g_app);
    Luna::close();
    return 0;
}
</code></pre>
<p>The first three lines includes the header files that we need to include to compile the program, which are:
* <Runtime/Runtime.hpp> for <code>Luna::init()</code> and <code>Luna::shutdown()</code>.</p>
<ul>
<li>
<p><Runtime/Module.hpp> for <code>Luna::init_modules()</code>.</p>
</li>
<li>
<p><Runtime/Debug.hpp> for <code>Luna::debug_printf()</code>.</p>
</li>
</ul>
<p>You can include any SDK interface header files using similar syntax: <code>#include &lt;Module/File&gt;</code>. We set <code>{LUNA_ROOT_DIR}/Engine</code> as the global include directory, the user may check it for available header files. In this example, all header files are from the <code>Runtime</code> module, which is the core module of Luna SDK that provides fundamental SDK features.</p>
<p>The next statement is <code>using namespace Luna</code>. In Luna SDK, all types, functions and variables are defined in <code>Luna</code> namespace, and every module will define its elements in nested namespace, such as <code>Luna::RHI</code>. So, we use this statement to prevent spelling the <code>Luna::</code> namespace prefix in our following code.</p>
<p>The program starts with the <code>main</code> function, just like any normal C/C++ program. In the main function, we firstly call <code>Luna::init</code> to initialize Luna SDK. This function should be called before any other Luna SDK function. <code>Luna::init</code> returns one Boolean value to indicate whether the SDK initialization is succeeded, if the return value is <code>false</code>, we then return <code>-1</code> and exit the program to indicate one runtime error. If <code>Luna::init</code> returns <code>true</code>, then one <code>Luna::close</code> call is need before the program exit to let the SDK clean up all internal resources.</p>
<p>We then wrap the real program logic in one <code>run_app</code> function. The return type of <code>run_app</code> is <code>RV</code>, which is a shortcut for <code>R&lt;void&gt;</code>, this is part of the error handling mechanism of Luna SDK. <code>R&lt;T&gt;</code> is a structure that encapsulates one return value with type <code>T</code> and one error code with type <code>ErrCode</code>, which is simply an alias of <code>usize</code> (or <code>std::size_t</code>). If the function succeeds, the returned value will be one <code>T</code>-typed value and one error code <code>0</code>; if the function fails, the returned value will be one non-zero error code, and the <code>T</code>-typed value will be uninitialized and inaccessible, you may call <code>errcode()</code> to fetch the error code from <code>R&lt;T&gt;</code>, and may call <code>explain</code> to get a brief description of the error. In our <code>main</code> function, we check whether our <code>run_app</code> function is failed by using <code>failed</code> helper function (there is also one <code>succeeded</code> helper function available), then we print the error description and exits the program if any error occurs.</p>
<p>In our <code>run_app</code> function, the first thing to do is calling <code>init_modules</code>, which will initialize all linked SDK modules for our program. We deliberately separate module initialization from <code>Luna::init</code> so that the user get a chance to set module initialization parameters before initializing modules, and modules can also indicate initialization failure by returning error codes (error handling system is available after <code>Luna::init</code>). Then, we allocate and initialize one new object of <code>DemoApp</code> type by calling <code>memnew</code> function. The following table shows memory allocation functions used in Luna SDK:</p>
<table>
<thead>
<tr>
<th>Luna SDK functions</th>
<th>C++ functions/keywords</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memalloc(size, alignment)</code></td>
<td><code>malloc(size)</code></td>
</tr>
<tr>
<td><code>memfree(ptr, alignment)</code></td>
<td><code>free(ptr)</code></td>
</tr>
<tr>
<td><code>memrealloc(ptr, size, alignment)</code></td>
<td><code>realloc(ptr, size)</code></td>
</tr>
<tr>
<td><code>memsize(size, alignment)</code></td>
<td>N/A</td>
</tr>
<tr>
<td><code>memnew&lt;T&gt;(args...)</code></td>
<td><code>new T (args...)</code></td>
</tr>
<tr>
<td><code>memdelete(ptr)</code></td>
<td><code>delete ptr</code></td>
</tr>
</tbody>
</table>
<p>The user should uses allocation functions provided by Luna SDK instead of those provided by C++ std. <code>DemoApp</code> will contain all states and logics for our demo program. The created <code>DempApp</code> instance then will be assigned to a global variable <code>g_app</code>, and will be deleted by <code>memdelete</code> when the program exits.</p>
<p><code>DemoApp</code> has three functions: <code>init</code>, <code>update</code> and <code>is_closed</code>. The <code>init</code> function initializes the program, and reports errors if the initialization is failed; the <code>update</code> function updates the program state and renders the image at every frame; the <code>is_exiting</code> function checks whether the program is exiting. We will implement these three methods in the following sections. </p>
<p>The rest part of our <code>run_app</code> function simply checks whether the program is exiting by calling <code>is_exiting</code>, and updates the program when it is not exiting. </p>
<p>After filling this content, execute <code>xmake build DemoApp</code> on terminal or click <code>build</code> button on your IDE, you should successfully build the <code>DemoApp</code> program.</p>
<h2 id="window-creation-and-event-handling">Window creation and event handling</h2>
<p>Now that we have one basic program structure, we need to create a system window so that we can render images to it. We also need to implement window event handling so that the program can exit when the user clicks the close button of the window.</p>
<p>Window creation is fairly simple, we firstly need to introduce one new header:</p>
<pre><code class="language-c++">#include &lt;Window/Window.hpp&gt;
</code></pre>
<p>then we add one new property to our <code>DemoApp</code> structure:</p>
<pre><code class="language-c++">struct DemoApp
{
    Ref&lt;Window::IWindow&gt; window;

    RV init();
    RV update();
    bool is_exiting();
    RV resize(u32 width, u32 height);
};
</code></pre>
<p>The window object is provided by <code>Window::IWindow*</code> interface pointer in Luna SDK, which points to a <em>boxed object</em> which manages its lifetime using <em>reference counting</em>. <code>IWindow</code> interface may have different implementations on different platforms, by they all provide the same functionality required by this interface. <code>Ref&lt;T&gt;</code> is a smart pointer for boxed objects, it will manage the reference counter of the pointing object automatically when being constructed and destructed, so the user does not need to call <code>object_retain</code> and <code>object_release</code> manually. You may compare <code>Ref&lt;T&gt;</code> to <code>ComPtr</code> used in Microsoft's Component-Object Model (COM), or the <em>automatic reference counting</em> in Apple's Objective-C and Swift. The default constructor of <code>Ref&lt;T&gt;</code> initializes the pointer to <code>nullptr</code>, so we need to assign it with a valid object.</p>
<p>Then we need to create our window in <code>DemoApp::init</code>:</p>
<pre><code class="language-c++">RV DemoApp::init()
{
    lutry
    {
        luset(window, Window::new_window(&quot;DemoApp&quot;, Window::WindowDisplaySettings::as_windowed(), Window::WindowCreationFlag::resizable));
    }
    lucatch
    {
        return lures;
    }
    return ok;
}
</code></pre>
<p>Besides the <code>new_window</code> function that creates the window, there are four new keywords in our code: <code>lutry</code>, <code>lucatch</code>, <code>luset</code> and <code>lures</code>. These four keywords are macros that enables us to write error handling using a simpler try-catch style, rather than fetching and checking error codes once and once again for every function call that may fail. <code>lutry</code> and <code>lucatch</code> must be used in pairs, next to each other. In the <code>lutry</code> block, the user may define multiple <code>lulet</code> , <code>luset</code> or <code>luexp</code> statements, <code>lulet</code> statement creates a new local variable to hold the  return value of the function, and jumps to <code>lucatch</code> if the function fails; <code>luset</code> assigns the return value to one existing variable, and jumps to <code>lucatch</code> if the function fails; <code>luexp</code> is used if the function does not return any value, it simply checks whether the function succeeds, and jumps to <code>lucatch</code> if not. The user may also call <code>luthrow</code> manually in <code>lutry</code> block to jump to <code>lucatch</code> directly.</p>
<p>In the <code>lucatch</code> block, <code>lures</code> is provided as the error code that causes the failure. You may use one <code>switch</code> statement on the <code>lures</code> to handle specific errors, or you can propagate the error directly to parent function by <code>return lures</code>. Since error propagating is so commonly used, we create another macro <code>lucatchret</code> to replace <code>lucatch { return lures; }</code>, so the code above can be written as:</p>
<pre><code class="language-c++">RV DemoApp::init()
{
    lutry
    {
        luset(window, Window::new_window(&quot;DemoApp&quot;, Window::WindowDisplaySettings::as_windowed(), Window::WindowCreationFlag::resizable));
    }
    lucatchret;
    return ok;
}
</code></pre>
<p>Since we use <code>goto</code> statement to implement <code>lutry</code> and <code>lucatch</code>, it you needs multiple lutry-lucatch pairs in one function, you should use a numbered version for every pair (like <code>lutry2</code>, <code>lucatch2</code>, <code>luset</code>2, <code>lures2</code>, etc.). In most cases, only one lutry-lucatch pair is sufficient.</p>
<p>Now let's get back to <code>Window::new_window</code> function that does the actual work:</p>
<pre><code class="language-c++">R&lt;Ref&lt;IWindow&gt;&gt; new_window(const c8* title, const WindowDisplaySettings&amp; display_settings, WindowCreationFlag flags)
</code></pre>
<p>In this function, <code>title</code> Specifies the title of the window, which is usually displayed on the title bar of the window. <code>flags</code> are a combination of <code>WindowCreationFlag</code> enumeration class that lists flags for window creation process, like whether the window is resizable by dragging the border of the window, whether the window is a border-less window, etc. <code>display_settings</code> specifies the display settings for the window, which is described by <code>WindowDisplaySettings</code> structre:</p>
<pre><code class="language-c++">struct WindowDisplaySettings
{
    monitor_t monitor;
    i32 x;
    i32 y;
    u32 width;
    u32 height;
    u32 refresh_rate;
    bool full_screen;
};
</code></pre>
<p>Every window can be displayed in windowed mode or full screen mode, which can be specified by <code>full_screen</code>. <code>monitor</code> specifies the monitor to attach the window to in full screen mode. If <code>monitor</code> is <code>nullptr</code> and the window is set to full screen mode, the primary monitor of the system will be used. <code>x</code> and <code>y</code> are the position of the window on screen coordinates in windowed mode. The user may pass <code>DEFAULT_POS</code> constant to indicate a system-specific default position for the window. <code>width</code> and <code>height</code> are used to control the size of the window, the user can pass <code>0</code> to indicate a system-specific default size. <code>refresh_rate</code> controls the refresh rate of the window, the user may pass <code>0</code> to use the default refresh rate of the system. <code>WindowDisplaySettings</code> comes with two static functions <code>as_windowed</code> and <code>as_full_screen</code> for quickly specify all parameters in one row, with default values specified when they are skipped by the user, just as in our example.</p>
<p>After the window is created, we need to register window event callbacks so that we can handle window events properly. In this example, the events we need to handle is the close event (triggered when the close button of the window is pressed) and the framebuffer resize event (triggered when the window framebuffer size is changed). This can be done by the following statements:</p>
<pre><code class="language-c++">window-&gt;get_close_event() += [](Window::IWindow* window) { window-&gt;close(); };
window-&gt;get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) {
    lupanic_if_failed(g_app-&gt;resize(width, height));
};
</code></pre>
<p><code>get_close_event</code> and <code>get_framebuffer_resize_event</code> are methods of <code>IWindow</code> that gets the close event and the framebuffer resize event object of the window. The event object is a collection of callback functions that once triggered, calls all the callback functions. We then register one callback function to the close event that closes the window immediately, and one callback function to the framebuffer resize event that calls the <code>resize</code> method of our <code>DempApp</code>. The <code>resize</code> method is currently empty, we will fill the content of this method when we create render textures later:</p>
<pre><code class="language-c++">RV DemoApp::resize(u32 width, u32 height)
{
    return ok;
}
</code></pre>
<p>Window events are not polled automatically, we need to tell the window system to poll events at every frame by calling <code>Window::poll_events</code> in <code>update</code> function:</p>
<pre><code class="language-c++">RV DemoApp::update()
{
    Window::poll_events();
    return ok;
}
</code></pre>
<p>This call polls events for all existing windows, so we don't need to provide specific window here. After we correctly handle the close event, we can complete the <code>is_closed</code> method of <code>DemoApp</code>:</p>
<pre><code class="language-c++">bool DemoApp::is_exiting()
{
    return window-&gt;is_closed();
}
</code></pre>
<p>So far, the complete code for <code>main.cpp</code> is:</p>
<pre><code class="language-c++">#include &lt;Runtime/Runtime.hpp&gt;
#include &lt;Runtime/Module.hpp&gt;
#include &lt;Runtime/Debug.hpp&gt;
#include &lt;Window/Window.hpp&gt;

using namespace Luna;

struct DemoApp
{
    Ref&lt;Window::IWindow&gt; window;

    RV init();
    RV update();
    bool is_exiting();
    RV resize(u32 width, u32 height);
};

DemoApp* g_app = nullptr;

RV DemoApp::init()
{
    lutry
    {
        luset(window, Window::new_window(&quot;DemoApp&quot;, Window::WindowDisplaySettings::as_windowed(), Window::WindowCreationFlag::resizable));
        window-&gt;get_close_event() += [](Window::IWindow* window) { window-&gt;close(); };
        window-&gt;get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) {
            lupanic_if_failed(g_app-&gt;resize(width, height));
        };

    }
    lucatchret;
    return ok;
}
RV DemoApp::update()
{
    Window::poll_events();
    return ok;
}
bool DemoApp::is_exiting()
{
    return window-&gt;is_closed();
}
RV DemoApp::resize(u32 width, u32 height)
{
    return ok;
}
RV run_app()
{
    auto result = init_modules();
    if(failed(result)) return result;
    g_app = memnew&lt;DemoApp&gt;();
    result = g_app-&gt;init();
    if(failed(result)) return result;
    while(!g_app-&gt;is_exiting())
    {
        result = g_app-&gt;update();
        if(failed(result)) return result;
    }
    return ok;
}
int main()
{
    bool initialized = Luna::init();
    if(!initialized) return -1;
    RV result = run_app();
    if(failed(result)) debug_printf(explain(result.errcode()));
    if(g_app) memdelete(g_app);
    Luna::close();
    return 0;
}
</code></pre>
<p>Build and run <code>DemoApp</code>, and you will see a blank window appears, and the program exits when you click the close button of the window.</p>
<p><img alt="" src="DemoApp-window.png" /></p>
<h2 id="fetching-graphics-device">Fetching graphics device</h2>
<p>After the window is created, we can start drawing our box. In Luna SDK, all graphics resources are related to one specific graphics device represented by <code>RHI::IDevice</code>, which is the virtual representation of the physical graphics device on the platform, so we need to add one property to <code>DemoApp</code> to hold this device:</p>
<pre><code class="language-c++">Ref&lt;RHI::IDevice&gt; dev;
</code></pre>
<p>When <code>RHI</code> module initializes, it automatically chooses the most suitable physical device and creates one device for you, which can be fetched by <code>RHI::get_main_device()</code>. You may also create additional devices for special use, but in our <code>DemoApp</code>, we will stick to the default one  by adding the following line in the <code>lutry</code> scope of <code>DemoApp::init</code>:</p>
<pre><code class="language-c++">dev = RHI::get_main_device();
</code></pre>
<p>We can also import all RHI types and functions by <code>using namespace RHI;</code> so that we don't need to spell them all over the <code>init</code> function:</p>
<pre><code class="language-c++">using namespace RHI;
</code></pre>
<p>The code of <code>DemoApp::init</code> should look similar to:</p>
<pre><code class="language-c++">RV DemoApp::init()
{
    lutry
    {
        luset(window, Window::new_window(&quot;DemoApp&quot;, Window::WindowDisplaySettings::as_windowed(), Window::WindowCreationFlag::resizable));
        window-&gt;get_close_event() += [](Window::IWindow* window) { window-&gt;close(); };
        window-&gt;get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) {
            lupanic_if_failed(g_app-&gt;resize(width, height));
        };

        dev = RHI::get_main_device();
        using namespace RHI;
        // New resource creation code goes here...
    }
    lucatchret;
    return ok;
}
</code></pre>
<p>Unless explicitly specified, all codes we need to add to <code>DemoApp::init</code> in the following sections are added to the end of <code>lutry</code> scope, not in the end of the function scope directly.</p>
<h2 id="creating-command-queue-and-command-buffer">Creating command queue and command buffer</h2>
<p>Luna SDK employs <em>deferred execution model</em>, where render and compute calls are recorded as <em>commands</em> in <em>command buffers</em>, then submitted to GPU explicitly by submitting <em>command buffers</em> to <em>command queues</em>. The command buffer object manages memory allocated to store commands, it also tracks the execution state for commands in the buffer when the buffer is submitted for execution. The command queue object is a FIFO message buffer between CPU and GPU. CPU can push command buffers into the queue, and GPU will pop command buffers from the queue and execute commands in the buffer. Command buffers in the queue are guaranteed to execute one after another, the next command buffer will not being executed until the last command buffer is finished.</p>
<p>We need to add two new properties to <code>DemoApp</code> to hold the command queue and command buffer:</p>
<pre><code class="language-c++">Ref&lt;RHI::ICommandQueue&gt; queue;
Ref&lt;RHI::ICommandBuffer&gt; cmdbuf;
</code></pre>
<p>Then we can create the objects by adding the following codes to <code>DemoApp::init</code>:</p>
<pre><code class="language-c++">luset(queue, dev-&gt;new_command_queue(CommandQueueType::graphics));
luset(cmdbuf, queue-&gt;new_command_buffer());
</code></pre>
<p>When creating command queues, we must specify the type of the queue. There are three different queue types: <code>graphics</code>, <code>compute</code> and <code>copy</code>. The copy queue only accepts copy commands, and is used for transferring data between different resources; the compute queue accepts copy and compute tasks, while the graphics queue accepts graphics, compute and copy commands. In our case, we need to create one graphics queue.</p>
<p>Note that command buffers are created from command queues, not from the graphics device directly. Once the command buffer is created, it is bound to the queue who created the buffer, and the binding can not be changed.</p>
<h2 id="creating-swap-chain">Creating swap chain</h2>
<p>The swap chain object contains resources that are used to present render results to our window. </p>
<p>We need to add one new property to <code>DemoApp</code> to hold the command queue and command buffer:</p>
<pre><code class="language-c++">Ref&lt;RHI::ISwapChain&gt; swap_chain;
</code></pre>
<p>In Luna SDK, the swap chain presentation is also a command that should be submitted using graphics command queues, so we need to specify the command queue we need to use when creating swap chains like so:</p>
<pre><code class="language-c++">luset(swap_chain, new_swap_chain(queue, window, SwapChainDesc(0, 0, 2, Format::rgba8_unorm, true)));
</code></pre>
<p>The swap chain is described by one <code>SwapChainDesc</code> structure:</p>
<pre><code class="language-c++">struct SwapChainDesc
{
    u32 width;
    u32 height;
    u32 buffer_count;
    Format pixel_format;
    bool vertically_synchronized;
};
</code></pre>
<p>When used for creating swap chains, you may pass <code>0</code> for <code>width</code> and <code>height</code> property, which indicates the system to use the window framebuffer size as the size of the swap chain.</p>
<p>The swap chain needs to be resized when the window framebuffer size is changed. This can be done by filling <code>DemoApp::resize</code> method with the following codes:</p>
<pre><code class="language-c++">RV DemoApp::resize(u32 width, u32 height)
{
    lutry
    {
        using namespace RHI;
        auto dev = get_main_device();
        luexp(swap_chain-&gt;reset({width, height, 2, Format::rgba8_unorm, true}));
    }
    lucatchret;
    return ok;
}
</code></pre>
<p><code>ISwapChain::reset</code> will reset the swap chain according to the new swap chain descriptor.</p>
<h2 id="creating-descriptor-set-layout-and-descriptor-set">Creating descriptor set layout and descriptor set</h2>
<p>The <em>descriptor set</em> object stores descriptors that bind resources to graphics or compute pipeline. Descriptors have the following types:</p>
<ol>
<li>Constant buffer view, which binds constant global data to shaders.</li>
<li>Shader resource view, which binds read-only textures and structured buffers to shaders.</li>
<li>Unordered access view, which binds writable resources to compute shaders.</li>
<li>Sampler, which stores sampling settings and exposes those settings for shaders.</li>
</ol>
<p>Every pipeline may bind multiple descriptor sets, every descriptor set may contain all four kinds of descriptors listed above. The <em>descriptor set layout</em> object stores the layout of one descriptor set object, including the number of descriptors in the descriptor set and the property of each descriptor.</p>
<p>In order to create one descriptor set layout object, we need to fill one <code>DescriptorSetLayoutDesc</code> structure. Here is the definition of <code>DescriptorSetLayoutDesc</code> structure:</p>
<pre><code class="language-c++">struct DescriptorSetLayoutDesc
{
    Vector&lt;DescriptorSetLayoutBinding&gt; bindings;
    DescriptorSetLayoutFlag flags = DescriptorSetLayoutFlag::none;
};
</code></pre>
<p>The descriptor set layout consists of multiple <em>bindings</em> specified by <code>DescriptorSetLayoutBinding</code>, each binding describes one range of the descriptor set:</p>
<pre><code class="language-c++">struct DescriptorSetLayoutBinding
{
    DescriptorType type;
    u32 binding_slot;
    u32 num_descs;
    ShaderVisibility shader_visibility;
};
</code></pre>
<p>the <code>type</code> property describes the type of this binding. All descriptors in the same binding must be the same type:</p>
<pre><code class="language-c++">enum class DescriptorType : u32
{
    srv,
    uav,
    cbv,
    sampler
};
</code></pre>
<p><code>binding_slot</code> and <code>num_descs</code> describes the binding slot range of this binding, starting from <code>0</code>. All slots in <code>[binding_slot, binding_slot + num_descs)</code> will be occupied by this binding and cannot be used by other bindings. If <code>num_descs</code> is greater than <code>1</code>, then this binding will be interpreted as one descriptor array in the shader. <code>shader_visibility</code> specifies which shader may access descriptors in this binding, you may restrict the visibility of one binding to one specific shader to potentially improve performance.</p>
<p>We need to add two new properties to <code>DemoApp</code> to hold the descriptor set layout object and the descriptor set object:</p>
<pre><code class="language-c++">Ref&lt;RHI::IDescriptorSetLayout&gt; dlayout;
Ref&lt;RHI::IDescriptorSet&gt; desc_set;
</code></pre>
<p>We need <strong>1</strong> descriptor set with <strong>1</strong> constant buffer view, <strong>1</strong> shader resource view and <strong>1</strong> sampler. So we can create our descriptor set layout object in <code>DemoApp::init</code> like so:</p>
<pre><code class="language-c++">luset(dlayout, dev-&gt;new_descriptor_set_layout(DescriptorSetLayoutDesc({
    {DescriptorType::cbv, 0, 1, ShaderVisibility::vertex},
    {DescriptorType::srv, 1, 1, ShaderVisibility::pixel},
    {DescriptorType::sampler, 2, 1, ShaderVisibility::pixel}
})));
</code></pre>
<p>Then we can create one descriptor set using the descriptor set layout object:</p>
<pre><code class="language-c++">luset(desc_set, dev-&gt;new_descriptor_set(DescriptorSetDesc(dlayout)));
</code></pre>
<p>We will fill descriptors in the set by calling <code>set_cbv</code>, <code>set_srv</code> and <code>set_sampler</code> later.</p>
<h2 id="compiling-shaders">Compiling shaders</h2>
<p>The next thing to do is compiling shaders for the pipeline state object. Luna SDK uses HLSL as the source shader language, and uses <code>ShaderCompiler</code> module to compile HLSL to DXBC, DXIL, SPIR-V and other target shading languages. To compile shader, we need to include corresponding header files:</p>
<pre><code class="language-c++">#include &lt;ShaderCompiler/ShaderCompiler.hpp&gt;
#include &lt;RHI/ShaderCompileHelper.hpp&gt;
</code></pre>
<p><code>ShaderCompileHelper.hpp</code> includes <code>RHI::get_current_platform_shader_target_format()</code> function, which tell the shader compiler the native target target shader format for the current graphics API. Since our shader is rather simple, we declare our shader source code directly in the C++ source file, in <code>DemoApp::init</code> function:</p>
<pre><code class="language-c++">const char vs_shader_code[] = R&quot;(
cbuffer vertexBuffer : register(b0)
{
    float4x4 world_to_proj;
};
struct VS_INPUT
{
    float3 position : POSITION;
    float2 texcoord : TEXCOORD;
};
struct PS_INPUT
{
    float4 position : SV_POSITION;
    float2 texcoord : TEXCOORD;
};
PS_INPUT main(VS_INPUT input)
{
    PS_INPUT output;
    output.position = mul(world_to_proj, float4(input.position, 1.0f));
    output.texcoord = input.texcoord;
    return output;
})&quot;;

const char ps_shader_code[] = R&quot;(
Texture2D tex : register(t1);
SamplerState tex_sampler : register(s2);
struct PS_INPUT
{
    float4 position : SV_POSITION;
    float2 texcoord : TEXCOORD;
};
float4 main(PS_INPUT input) : SV_Target
{
    return float4(tex.Sample(tex_sampler, input.texcoord));
})&quot;;
</code></pre>
<p>here we use C++ raw string syntax <code>R"()"</code> to declare multiline string without appending <code>\</code> for every string line. Note the register number specified in shader must match the binding slot specified in descriptor set layout we just created. Since we use the same slot numbering system for all descriptor types, the register number for <code>b</code>, <code>t</code>, <code>u</code> and <code>s</code> should not overlap.</p>
<p>Then we can compile shaders using <code>ShaderCompiler::ICompiler</code> object:</p>
<pre><code class="language-c++">auto compiler = ShaderCompiler::new_compiler();
compiler-&gt;set_source({ vs_shader_code, strlen(vs_shader_code) });
compiler-&gt;set_source_name(&quot;DemoAppVS&quot;);
compiler-&gt;set_entry_point(&quot;main&quot;);
compiler-&gt;set_target_format(RHI::get_current_platform_shader_target_format());
compiler-&gt;set_shader_type(ShaderCompiler::ShaderType::vertex);
compiler-&gt;set_shader_model(5, 0);
compiler-&gt;set_optimization_level(ShaderCompiler::OptimizationLevel::full);
luexp(compiler-&gt;compile());
auto vs_data = compiler-&gt;get_output();
Blob vs(vs_data.data(), vs_data.size());

compiler-&gt;reset();
compiler-&gt;set_source({ ps_shader_code, strlen(ps_shader_code) });
compiler-&gt;set_source_name(&quot;DemoAppPS&quot;);
compiler-&gt;set_entry_point(&quot;main&quot;);
compiler-&gt;set_target_format(RHI::get_current_platform_shader_target_format());
compiler-&gt;set_shader_type(ShaderCompiler::ShaderType::pixel);
compiler-&gt;set_shader_model(5, 0);
compiler-&gt;set_optimization_level(ShaderCompiler::OptimizationLevel::full);
luexp(compiler-&gt;compile());
auto ps_data = compiler-&gt;get_output();
Blob ps(ps_data.data(), ps_data.size());
</code></pre>
<p>The shader compilation process is fairly simple, we just set source code, compilation settings, then triggers the compilation. The compilation result will be given by <code>get_output</code>, we use one <code>Blob</code> object , a container for binary data, to hold the compilation result. The compiled shader data will be used when creating pipeline state object later.</p>
<h2 id="creating-shader-input-layout-and-pipeline-state">Creating shader input layout and pipeline state</h2>
<p>The graphics and compute pipeline state is described by two objects: shader input layout object and pipeline state object. Shader input layout object stores the shader binding layout information for all shader stages, while pipeline state object stores pipeline settings for all graphics stages. </p>
<p>Shader input layout is described by the <code>ShaderInputLayoutDesc</code> structure, which is set by specifying layouts of descriptor sets that will be bound to this pipeline and flags that specifies shaders that are allowed to access shader inputs.</p>
<pre><code class="language-c++">struct ShaderInputLayoutDesc
{
    Vector&lt;IDescriptorSetLayout*&gt; descriptor_set_layouts;
    ShaderInputLayoutFlag flags;
};
</code></pre>
<p>We need to add one new property to <code>DemoApp</code> to hold the shader input layout object:</p>
<pre><code class="language-c++">Ref&lt;RHI::IShaderInputLayout&gt; slayout;
</code></pre>
<p>Then we can create shader input layout object using the following code:</p>
<pre><code class="language-c++">luset(slayout, dev-&gt;new_shader_input_layout(ShaderInputLayoutDesc({dlayout}, 
    ShaderInputLayoutFlag::allow_input_assembler_input_layout |
    ShaderInputLayoutFlag::deny_hull_shader_access |
    ShaderInputLayoutFlag::deny_domain_shader_access |
    ShaderInputLayoutFlag::deny_geometry_shader_access)));
</code></pre>
<p>The pipeline object is described by the <code>GraphicsPipelineStateDesc</code> structure or the <code>ComputePipelineStateDesc</code> structure. Since we are creating one graphics pipeline, we need to fill the <code>GraphicsPipelineStateDesc</code>  structure, which is a complex structure that contains all pipeline settings for one graphics pipeline:</p>
<pre><code class="language-c++">struct GraphicsPipelineStateDesc
{
    InputLayoutDesc input_layout;
    IShaderInputLayout* shader_input_layout = nullptr;
    Span&lt;const byte_t&gt; vs;
    Span&lt;const byte_t&gt; ps;
    Span&lt;const byte_t&gt; ds;
    Span&lt;const byte_t&gt; hs;
    Span&lt;const byte_t&gt; gs;
    StreamOutputDesc stream_output;
    BlendDesc blend_state;
    RasterizerDesc rasterizer_state;
    DepthStencilDesc depth_stencil_state;
    IndexBufferStripCutValue ib_strip_cut_value = IndexBufferStripCutValue::disabled;
    PrimitiveTopologyType primitive_topology_type = PrimitiveTopologyType::triangle;
    u32 num_render_targets = 0;
    Format rtv_formats[8] = { Format::unknown };
    Format dsv_format = Format::unknown;
    u32 sample_count = 1;
    u32 sample_mask = 0xFFFFFFFF;
    u32 sample_quality = 0;
};
</code></pre>
<p>Most graphic settings are similar to those in D3D11, D3D12, OpenGL or Vulkan, we will not explain these settings, but only gives the code that correctly sets every setting of the pipeline. You can see docs for <code>RHI</code> module for detailed explanations of these settings.</p>
<p>We need to add one new property to <code>DemoApp</code> to hold the pipeline state object:</p>
<pre><code class="language-c++">Ref&lt;RHI::IPipelineState&gt; pso;
</code></pre>
<p>Then we can create pipeline state object using the following code:</p>
<pre><code class="language-c++">GraphicsPipelineStateDesc ps_desc;
ps_desc.primitive_topology_type = PrimitiveTopologyType::triangle;
ps_desc.sample_mask = U32_MAX;
ps_desc.sample_quality = 0;
ps_desc.blend_state = BlendDesc(false, false, { RenderTargetBlendDesc(false, false, BlendFactor::src_alpha,
    BlendFactor::inv_src_alpha, BlendOp::add, BlendFactor::inv_src_alpha, BlendFactor::zero, BlendOp::add, LogicOp::noop, ColorWriteMask::all) });
ps_desc.rasterizer_state = RasterizerDesc(FillMode::solid, CullMode::back, 0, 0.0f, 0.0f, 0, false, true, false, false, false);
ps_desc.depth_stencil_state = DepthStencilDesc(true, true, ComparisonFunc::less_equal, false, 0x00, 0x00, DepthStencilOpDesc(), DepthStencilOpDesc());
ps_desc.ib_strip_cut_value = IndexBufferStripCutValue::disabled;
ps_desc.input_layout = InputLayoutDesc({
    {&quot;POSITION&quot;, 0, Format::rgb32_float},
    {&quot;TEXCOORD&quot;, 0, Format::rg32_float},
});
ps_desc.vs = vs.cspan();
ps_desc.ps = ps.cspan();
ps_desc.shader_input_layout = slayout;
ps_desc.num_render_targets = 1;
ps_desc.rtv_formats[0] = Format::rgba8_unorm;
ps_desc.dsv_format = Format::d32_float;
luset(pso, dev-&gt;new_graphics_pipeline_state(ps_desc));
</code></pre>
<h2 id="creating-render-and-depth-textures">Creating render and depth textures</h2>
<p>The next step is to create the render texture and depth texture that is used as render target and depth stencil target. We also need to create <em>render target view</em> object and <em>depth stencil view</em> object for our render texture and depth texture.</p>
<p>All graphic resources in Luna SDK, including buffers and textures, are described by <code>ResourceDesc</code> structure, and are represented by <code>IResource</code> interface. Here is the definition of the<code>ResourceDesc</code> structure:</p>
<pre><code class="language-c++">struct ResourceDesc
{
    ResourceType type;
    ResourceHeapType heap_type;
    Format pixel_format;
    ResourceUsageFlag usages;
    u64 width_or_buffer_size;
    u32 height;
    u32 depth_or_array_size;
    u32 mip_levels;
    u32 sample_count;
    u32 sample_quality;
    ResourceFlag flags;
};
</code></pre>
<p><code>type</code> specifies the type of the resource, like <code>buffer</code>, <code>texture_2d</code>, etc. <code>heap_type</code> specifies which memory heap to create the resource in, possible options include:</p>
<ol>
<li><code>local</code> - The resource can only be accessed by GPU, CPU access is disabled. This heap is suitable for GPU generated resources like temporary texture between render passes.</li>
<li><code>shared</code> and <code>shared_upload</code> - The resource can be accessed by both GPU and CPU, but is optimized for maximum GPU bandwidth, CPU access is slow and limited. <code>shared_upload</code> only allows CPU-write, while <code>shared</code> allows both CPU read and write. This heap is suitable for CPU-write-once textures like static textures read from file.</li>
<li><code>upload</code> - The resource can be written by CPU and read by GPU. This heap is suitable for resources that should be updated by CPU frequently. Textures cannot be created in this heap.</li>
<li><code>readback</code> - The resource can be written by GPU and read by CPU. This heap is suitable for transferring data from GPU to CPU frequently. Textures cannot be created in this heap.</li>
</ol>
<p><code>pixel_format</code> specifies the pixel format of the resource if the resource is a texture, otherwise is ignored and will be set to <code>unknown</code>. <code>usages</code> specifies all possible roles of the resource when being bound to a pipeline. <code>width_or_buffer_size</code>, <code>height</code> and <code>depth_or_array_size</code>  specifies the size of the resource, if the resource is a buffer, only <code>width_or_buffer_size</code> is used, and specifies the size of the buffer in bytes, otherwise, based on the <code>type</code> of the resource, those three properties specifies the width, height, depth (for 3D textures) or array size (for 1D and 2D textures) of the resource. <code>mip_levels</code> specifies the number of mips that should be allocated for the resource, if this is <code>0</code>, the system allocates full mipmap chain for the resource. <code>sample_count</code> and <code>sample_quality</code> specifies the sampling configuration for MSAA textures. <code>flags</code> specifies additional flags for the texture, like whether this texture can be simultaneously accessed by multiple command queues.</p>
<p>To simplify the resource specification, we can use static methods provided by <code>ResourceDesc</code> to quickly construct <code>ResourceDesc</code> structure:</p>
<pre><code class="language-c++">ResourceDesc ResourceDesc::buffer(ResourceHeapType heap_type, ResourceUsageFlag usages, u64 size, ResourceFlag flags = ResourceFlag::none);

ResourceDesc ResourceDesc::tex1d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u64 width, u32 array_size = 1, u32 mip_levels = 0, ResourceFlag flags = ResourceFlag::none);

ResourceDesc ResourceDesc::tex2d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u32 width, u32 height, u32 array_size = 1, u32 mip_levels = 0, u32 sample_count = 1, u32 sample_quality = 0, ResourceFlag flags = ResourceFlag::none);

ResourceDesc ResourceDesc::tex3d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u32 width, u32 height, u32 depth, u32 mip_levels = 0, ResourceFlag flags = ResourceFlag::none);
</code></pre>
<p>Back to our <code>DemoApp</code>, we need to add four new properties to <code>DemoApp</code> to hold the render texture, the depth texture, and two views:</p>
<pre><code class="language-c++">Ref&lt;RHI::IResource&gt; rt_tex;
Ref&lt;RHI::IRenderTargetView&gt; rtv;
Ref&lt;RHI::IResource&gt; depth_tex;
Ref&lt;RHI::IDepthStencilView&gt; dsv;
</code></pre>
<p>Then we can create textures using the following code:</p>
<pre><code class="language-c++">auto window_size = window-&gt;get_framebuffer_size();

luset(rt_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, window_size.x, window_size.y, 1, 1)));

luset(depth_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, window_size.x, window_size.y, 1, 1)));
</code></pre>
<p>Note that when retrieving window size for rendering, we need to call <code>IWindow::get_framebuffer_size</code> instead of <code>IWindow::get_size</code>, on some platforms the window size is not necessary measured in pixels, causing these two methods return different values.</p>
<p>We then need to create the render target view and depth stencil view for these two textures. Render target views and depth stencil views describes which portion of the texture will be bound to the graphic pipeline. Unlike other views, these two views are represented by dedicated objects: <code>IRenderTargetView</code> and <code>IDepthStencilView</code>, they can be created using the following code:</p>
<pre><code class="language-c++">luset(rtv, dev-&gt;new_render_target_view(rt_tex));
luset(dsv, dev-&gt;new_depth_stencil_view(depth_tex));
</code></pre>
<p>these two methods accepts additional <code>RenderTargetViewDesc</code> and <code>DepthStencilViewDesc</code> structures when creating views, but since we are using the default settings, these two structures can be omitted.</p>
<p>Since we are using the window size as the render texture size, these textures should also be recreated when the window framebuffer is changed. This can be done by adding the following code to the <code>DemoApp::resize</code> method:</p>
<pre><code class="language-c++">luset(rt_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, 
    ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, width, height, 1, 1)));
luset(depth_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, 
     ResourceUsageFlag::depth_stencil, width, height, 1, 1)));
luset(rtv, dev-&gt;new_render_target_view(rt_tex));
luset(dsv, dev-&gt;new_depth_stencil_view(depth_tex));
</code></pre>
<h2 id="creating-buffers">Creating buffers</h2>
<p>The next step is to create buffers used in our <code>DemoApp</code>, including:</p>
<ol>
<li>The vertex buffer and index buffer for our box mesh.</li>
<li>The constant buffer for camera properties.</li>
</ol>
<p>Firstly we need to define the vertex structure of our box. Adding the following code after the declaration of <code>DemoApp</code> structure:</p>
<pre><code class="language-c++">struct Vertex
{
    Float3U position;
    Float2U texcoord;
};
</code></pre>
<p><code>Float2U</code> and <code>Float3U</code> are vector types used in Luna SDK, which represent 2D and 3D vectors. In Luna SDK, we have 16-bytes aligned vector types <code>Float2</code>, <code>Float3</code>, <code>Float4</code>, and unaligned vector types <code>Float2U</code>, <code>Float3U</code> and <code>Float4U</code>. The aligned vector types are used for calculations, SIMD functions like <code>min</code>, <code>max</code>, <code>lerp</code>, <code>clamp</code> only accepts aligned types, while unaligned vector types are used for storing and transferring data, such as in this case. The size of aligned vector types are all 16 bytes, while the size of unaligned types are 8, 12 and 16 for <code>Float2U</code>, <code>Float3U</code> and <code>Float4U</code>.</p>
<p>We need to add three new properties to <code>DemoApp</code> to hold the these three buffers:</p>
<pre><code class="language-c++">Ref&lt;RHI::IResource&gt; vb;
Ref&lt;RHI::IResource&gt; ib;
Ref&lt;RHI::IResource&gt; cb;
</code></pre>
<p>Then, we need to create the vertex buffer and index buffer for our box using the following code:</p>
<pre><code class="language-c++">Vertex vertices[] = {
    {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, +0.5, -0.5}, {0.0, 0.0}},
    {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, -0.5, +0.5}, {1.0, 1.0}},
    {{+0.5, -0.5, +0.5}, {0.0, 1.0}}, {{+0.5, +0.5, +0.5}, {0.0, 0.0}},
    {{-0.5, +0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 1.0}},
    {{-0.5, -0.5, +0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}},
    {{-0.5, +0.5, -0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}},
    {{-0.5, -0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 0.0}},
    {{+0.5, +0.5, -0.5}, {1.0, 0.0}}, {{+0.5, -0.5, -0.5}, {1.0, 1.0}},
    {{-0.5, +0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}},
    {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 1.0}},
    {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 0.0}},
    {{-0.5, -0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}}
};
u32 indices[] = {
    0, 1, 2, 0, 2, 3, 
    4, 5, 6, 4, 6, 7, 
    8, 9, 10, 8, 10, 11,
    12, 13, 14, 12, 14, 15,
    16, 17, 18, 16, 18, 19,
    20, 21, 22, 20, 22, 23
};
luset(vb, dev-&gt;new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::vertex_buffer, sizeof(vertices))));
luset(ib, dev-&gt;new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::index_buffer, sizeof(indices))));
void* mapped = nullptr;
luexp(vb-&gt;map_subresource(0, false, &amp;mapped));
memcpy(mapped, vertices, sizeof(vertices));
vb-&gt;unmap_subresource(0, true);
luexp(ib-&gt;map_subresource(0, false, &amp;mapped));
memcpy(mapped, indices, sizeof(indices));
ib-&gt;unmap_subresource(0, true);
</code></pre>
<p>We firstly define vertex and index data for our box, then we create two buffer resources to hold the vertex and index data. Those two resources are created in <code>shared_upload</code> heap, so we can upload data to the resource, while still achieving maximum GPU bandwidth.  After the resource is created, we can map the resource to system memory by calling <code>IResource::map</code>, and retrieving one pointer to the memory, then we use <code>memcpy</code> to copy buffer data, and use <code>IResource::unmap</code> to release the memory mapping, and store the data to the resource.</p>
<p>We can use similar code to create the constant buffer for uploading camera properties, but there are two differences. First, the graphic device usually has alignment requirements for constant buffers, which can be fetched from <code>IDevice::get_constant_buffer_data_alignment()</code>, so we use <code>align_upper</code> helper function to adjust the size of our constant buffer resource to meet the alignment requirement. Second, since we need to update constant buffer data once every frame, we should choose <code>upload</code> heap instead of <code>shared_upload</code> for maximum CPU bandwidth.</p>
<p>In our <code>DemoApp</code>, the data of the constant buffer is the 4x4 world-to-project matrix of the camera. We need to add a new include file to use matrix types:</p>
<pre><code class="language-c++">#include &lt;Runtime/Math/Matrix.hpp&gt;
</code></pre>
<p>then we can use the following code to create constant buffer:</p>
<pre><code class="language-c++">auto cb_align = dev-&gt;get_constant_buffer_data_alignment();
luset(cb, dev-&gt;new_resource(ResourceDesc::buffer(ResourceHeapType::upload, ResourceUsageFlag::constant_buffer, align_upper(sizeof(Float4x4), cb_align))));
</code></pre>
<p>as you can see, <code>Float4x4</code> is the matrix type used in Luna SDK. We also have <code>Float3x3</code> for 2D affine transformations.</p>
<h2 id="loading-image-from-file">Loading image from file</h2>
<p>The next step is to load our Luna LOGO image that will be drawn on the box surface:</p>
<p><img alt="" src="luna.png" /></p>
<p>Save the image file in the same directory as <code>main.cpp</code>, and naming it <code>luna.png</code>. You should have one file structure similar to this:</p>
<pre><code>DemoApp
|- xmake.lua
|- main.cpp
|- luna.png
</code></pre>
<p>Then fills <code>xmake.lua</code> with the following code:</p>
<pre><code class="language-lua">target(&quot;DemoApp&quot;)
    set_luna_sdk_program()
    add_headerfiles(&quot;**.hpp&quot;)
    add_files(&quot;**.cpp&quot;)
    add_deps(&quot;Runtime&quot;, &quot;Window&quot;, &quot;RHI&quot;, &quot;ShaderCompiler&quot;, &quot;Image&quot;)
    before_build(function(target)
        os.cp(&quot;$(scriptdir)/luna.png&quot;, target:targetdir() .. &quot;/luna.png&quot;)
    end)
    after_install(function (target)
        os.cp(target:targetdir() .. &quot;/luna.png&quot;, target:installdir() .. &quot;/bin/luna.png&quot;)
    end)
target_end()
</code></pre>
<p>This script triggers registers custom functions before building the program and after installing the program, the custom function copies the image file to same the directory of our program binary file, so that our program can correctly find the image file.</p>
<p>We firstly need to add one new property to <code>DemoApp</code> to represent the loaded image:</p>
<pre><code class="language-c++">Ref&lt;RHI::IResource&gt; file_tex;
</code></pre>
<p>To load the image in our program, we need to use one new module called <code>Image</code>, which parses image file data and gives row-majored image data in our desired format. We also need to use the file API provided by <code>Runtime</code> module, so we includes two new headers:</p>
<pre><code class="language-c++">#include &lt;Runtime/File.hpp&gt;
#include &lt;Image/Image.hpp&gt;
</code></pre>
<p>The first thing to do is to load image file data from our <code>luna.png</code> file. In order to load file data, we need to use the <code>open_file</code> function provided by the <code>Runtime</code> module. This function returns one file handle represented by <code>IFile</code> if the file is correctly opened. Then, we loads the file data into one <code>Blob</code> object by calling <code>load_file_data</code>, this function creates one properly-sized blob object, and calls <code>IFile::read</code> to read all data of the file to the blob, then returns the blob:</p>
<pre><code class="language-c++">lulet(image_file, open_file(&quot;Luna.png&quot;, FileOpenFlag::read, FileCreationMode::open_existing));
lulet(image_file_data, load_file_data(image_file));
</code></pre>
<p>Now that the file data has been stored in <code>image_file_data</code>, we need to call <code>Image::read_image_file</code> function to parse the file data and gives the real image data:</p>
<pre><code class="language-c++">Image::ImageDesc image_desc;
lulet(image_data, Image::read_image_file(image_file_data.data(), image_file_data.size(), Image::ImagePixelFormat::rgba8_unorm, image_desc));
</code></pre>
<p><code>Image::read_image_file</code> function outputs one <code>Image::ImageDesc</code> structure that describes the returned image data, including the width, height and pixel format of the image. The image data is arranged in a row-major manner and without and alignment padding. We then creates one new resource, and uploads the data to the resource:</p>
<pre><code class="language-c++">luset(file_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::shared_upload, Format::rgba8_unorm, 
    ResourceUsageFlag::shader_resource, image_desc.width, image_desc.height, 1, 1)));
luexp(file_tex-&gt;map_subresource(0, false));
luexp(file_tex-&gt;write_subresource(0, image_data.data(), 
    image_desc.width * Image::pixel_size(image_desc.format), 
    image_desc.width * image_desc.height * Image::pixel_size(image_desc.format), BoxU(0, 0, 0, image_desc.width, image_desc.height, 1)));
file_tex-&gt;unmap_subresource(0, true);
</code></pre>
<p>Note that for texture resources, we cannot fetch pointers to the mapped data and copy data directly using <code>memcpy</code> like those in buffer resources. Instead, we need to call <code>IResource::write_subresource</code> after <code>IResource::map_subresource</code> to let the system copy data to the resource memory. The resource is created in <code>shared_upload</code> heap, which is the common option for resources whose data will be loaded from file.</p>
<h2 id="set-up-descriptor-set">Set up descriptor set</h2>
<p>Once the constant buffer and file texture is set up, we can bind these two resources to the descriptor set that we need to bind to the pipeline state later. We also need to set the sampler in the descriptor set to be used by the pixel shader.</p>
<pre><code class="language-c++">desc_set-&gt;set_cbv(0, cb, ConstantBufferViewDesc(0, align_upper(sizeof(Float4x4), cb_align)));
desc_set-&gt;set_srv(1, file_tex);
desc_set-&gt;set_sampler(2, SamplerDesc(FilterMode::min_mag_mip_linear, TextureAddressMode::clamp,
                TextureAddressMode::clamp, TextureAddressMode::clamp, 0.0f, 1, ComparisonFunc::always, 
                Float4U(0, 0, 0, 0), 0.0f, 0.0f));
</code></pre>
<p>This concludes the <code>DemoApp::init</code> function.</p>
<h2 id="camera-control">Camera control</h2>
<p>Now that we have created all resources required to draw the box, we need to fill the actual drawing code in <code>DemoApp::update</code>. To make our program more interesting, we can apply one simple animation that rotates the camera around the box. We firstly adds one new property to <code>DemoApp</code> that stores the rotation angle of the camera:</p>
<pre><code class="language-c++">f32 camera_rotation = 0.0f;
</code></pre>
<p>We can increase the rotation angle of the camera by one at every frame by adding the following line to the end of <code>DemoApp:update</code>:</p>
<pre><code class="language-c++">camera_rotation += 1.0f;
</code></pre>
<p>Since we are going to use many functions that may throw errors, it is better to declare one <code>lutry</code>-<code>lucatch</code> scope that wraps all succeeding codes in <code>DemoApp:update</code>:</p>
<pre><code class="language-c++">RV DemoApp::update()
{
    Window::poll_events();
    if(window-&gt;is_closed()) return ok;
    lutry
    {
        camera_rotation += 1.0f;
        // More codes goes here...
    }
    lucatchret;
    return ok;
}
</code></pre>
<p>After we updates the camera rotation, we need to calculate the view-projection matrix for the camera. Fortunately, the math library of the <code>Runtime</code> module already includes implementations for many commonly used vector and matrix calculations, and here we are going to use two of them: <code>AffineMatrix::make_look_at</code> and <code>ProjectionMatrix::make_perspective_fov</code>:</p>
<pre><code class="language-c++">Float3 camera_pos(cosf(camera_rotation / 180.0f * PI) * 2.0f, 1.0f, sinf(camera_rotation / 180.0f * PI) * 2.0f);
Float4x4 camera_mat = AffineMatrix::make_look_at(camera_pos, Float3(0, 0, 0), Float3(0, 1, 0));
auto window_sz = window-&gt;get_framebuffer_size();
camera_mat = mul(camera_mat, ProjectionMatrix::make_perspective_fov(PI / 3.0f, (f32)window_sz.x / (f32)window_sz.y, 0.001f, 100.0f));
</code></pre>
<p>The <code>AffineMatrix</code> namespace includes common functions for generating and decomposing 3D affine matrices. In our example, <code>AffineMatrix::make_look_at</code> generates one camera view matrix from the position of the camera and the position of the point to look at. <code>ProjectionMatrix::make_perspective_fov</code> is another helper function that generates one projection matrix from the specified field-of-view and aspect ratio values. Those two matrices are multiplied by <code>mul</code> function to get the final view-projection matrix. Note that when performing matrix multiplications, use <code>mul</code> instead of operator <code>*</code>, the later one is used to multiply each element in the matrix separately.</p>
<p>After we get the matrix, we can upload the matrix data to our constant buffer using the syntax similar to those for vertex and index buffers:</p>
<pre><code class="language-c++">void* camera_mapped;
luexp(cb-&gt;map_subresource(0, false, &amp;camera_mapped));
memcpy(camera_mapped, &amp;camera_mat, sizeof(Float4x4));
cb-&gt;unmap_subresource(0, true);
</code></pre>
<h2 id="resource-barriers">Resource barriers</h2>
<p>In Luna SDK, every graphic resource has one state that describes the current memory layout and pipeline access polity of the resource. Before we can issue draw calls, we need to transfer every resource we use to their correct states. Luna SDK requires the user to transfer the state explicitly by calling <code>ICommandBuffer::resource_barriers</code> with transition-typed resource barriers. In our example, we need to perform the following transitions:</p>
<pre><code class="language-c++">cmdbuf-&gt;resource_barriers({
    ResourceBarrierDesc::as_transition(cb, ResourceState::vertex_and_constant_buffer),
    ResourceBarrierDesc::as_transition(vb, ResourceState::vertex_and_constant_buffer),
    ResourceBarrierDesc::as_transition(ib, ResourceState::index_buffer),
    ResourceBarrierDesc::as_transition(file_tex, ResourceState::shader_resource_pixel),
    ResourceBarrierDesc::as_transition(rt_tex, ResourceState::render_target),
    ResourceBarrierDesc::as_transition(depth_tex, ResourceState::depth_stencil_write)
});
</code></pre>
<p>Luna SDK internally manages the current state for all resources, so we only need to specify the state of the resource <strong>after</strong> the transition. Luna SDK also omits unnecessary transitions automatically if the before and after state of one resource is same or compatible.</p>
<h2 id="drawing-the-box">Drawing the box</h2>
<p>Finally, we can issue the draw call that draws our box:</p>
<pre><code class="language-c++">RenderPassDesc desc;
desc.rtvs[0] = rtv;
desc.rt_load_ops[0] = LoadOp::clear;
desc.rt_store_ops[0] = StoreOp::store;
desc.rt_clear_values[0] = {0, 0, 0, 0};
desc.dsv = dsv;
desc.depth_load_op = LoadOp::clear;
desc.depth_store_op = StoreOp::store;
desc.depth_clear_value = 1.0f;
desc.stencil_load_op = LoadOp::dont_care;
desc.stencil_store_op = StoreOp::dont_care;
cmdbuf-&gt;begin_render_pass(desc);
cmdbuf-&gt;set_graphics_shader_input_layout(slayout);
cmdbuf-&gt;set_pipeline_state(pso);
cmdbuf-&gt;set_graphics_descriptor_set(0, desc_set);
cmdbuf-&gt;set_primitive_topology(PrimitiveTopology::triangle_list);
auto sz = vb-&gt;get_desc().width_or_buffer_size;
cmdbuf-&gt;set_vertex_buffers(0, {VertexBufferViewDesc(vb, 0, sz, sizeof(Vertex))});
sz = ib-&gt;get_desc().width_or_buffer_size;
cmdbuf-&gt;set_index_buffer(IndexBufferViewDesc(ib, 0, sz, Format::r32_uint));
cmdbuf-&gt;set_scissor_rect(RectI(0, 0, (i32)window_sz.x, (i32)window_sz.y));
cmdbuf-&gt;set_viewport(Viewport(0.0f, 0.0f, (f32)window_sz.x, (f32)window_sz.y, 0.0f, 1.0f));
cmdbuf-&gt;draw_indexed(36, 0, 0);
cmdbuf-&gt;end_render_pass();
</code></pre>
<p>The first thing to do is to begin a <em>render pass</em> that attaches one set of render targets and/or the depth stencil target to the graphic pipeline, these render resources are bound to the pipeline during the current render pass and cannot be changed, while all other settings (like shader input layout object, pipeline state object, descriptor sets, etc) can be changed within the same render pass.</p>
<p>The render pass begins with <code>ICommandBuffer::begin_render_pass</code>. In the render pass, we set up all pipeline settings, and bind all resources required for the current draw call, then calls <code>ICommandBuffer::draw_indexed</code> to issue the draw call based on the current settings. Then we should close the render pass by calling <code>ICommandBuffer::end_render_pass</code>. We won't go detail about the pipeline setup for this draw call, they should be familiar to you if you have been using other graphics API before. For further explanations, please consult the documentations for the <code>RHI</code> module.</p>
<p>As we have said before, commands in the command buffer will not be executed immediately, they should be submitted to the command queue explicitly to get executed. So we do it here:</p>
<pre><code class="language-c++">luexp(cmdbuf-&gt;submit());
</code></pre>
<p>This transfers the command buffer to the execution state, so we can no longer adding commands to the command buffer until we reset the command buffer using <code>ICommandBuffer::reset</code>.</p>
<h2 id="presenting-the-render-result">Presenting the render result</h2>
<p>The last thing is to present our rendering result to the window (or precisely, the back buffer in the window swap chain), and this is done by calling <code>ISwapChain::presnet</code>:</p>
<pre><code class="language-c++">luexp(swap_chain-&gt;present(rt_tex, 0));
</code></pre>
<p>The two parameters are the texture resource and subresource id to get displayed, and the system will blit the texture to the back buffer. For compatibility reasons, the user cannot fetch the back buffer directly like in other graphic APIs, this will bring one extra blit overhead on some platforms, but it won't be the bottleneck of your program for most cases.</p>
<p>In Luna SDK, the present call is not synchronous, it only pushes the present command into the bounding command queue and returns directly. We should explicitly wait for the present command to be finished by calling <code>ISwapChain::wait</code> before we can start the next frame:</p>
<pre><code class="language-c++">swap_chain-&gt;wait();
</code></pre>
<p>Since we submitted the command buffer before the present call, when the present command is finished, the command buffer is guaranteed to be finished, so that we don't need to call <code>cmdbuf-&gt;wait()</code> explicitly and can reset the command buffer safely now:</p>
<pre><code class="language-c++">luexp(cmdbuf-&gt;reset());
</code></pre>
<p>This concludes the <code>DemoApp::update</code> function. Build and run <code>DemoApp</code>, if everything goes correctly, you will see a textured rotating box in the screen:</p>
<p><img alt="" src="DemoApp-final.png" /></p>
<p>Congratulations! If you have followed every step of this article correctly, you should have a first impression of graphic programming using Luna SDK. If anything goes wrong, you can compare your code with the following reference code to identify the mistake.</p>
<h2 id="reference-code-for-maincpp">Reference code for <code>main.cpp</code></h2>
<pre><code class="language-c++">#include &lt;Runtime/Runtime.hpp&gt;
#include &lt;Runtime/Module.hpp&gt;
#include &lt;Runtime/Debug.hpp&gt;
#include &lt;Window/Window.hpp&gt;
#include &lt;RHI/RHI.hpp&gt;
#include &lt;ShaderCompiler/ShaderCompiler.hpp&gt;
#include &lt;RHI/ShaderCompileHelper.hpp&gt;
#include &lt;Runtime/Math/Matrix.hpp&gt;
#include &lt;Runtime/File.hpp&gt;
#include &lt;Image/Image.hpp&gt;
#include &lt;Runtime/Math/Transform.hpp&gt;

using namespace Luna;

struct DemoApp
{
    Ref&lt;Window::IWindow&gt; window;

    Ref&lt;RHI::IDevice&gt; dev;
    Ref&lt;RHI::ICommandQueue&gt; queue;
    Ref&lt;RHI::ICommandBuffer&gt; cmdbuf;
    Ref&lt;RHI::ISwapChain&gt; swap_chain;
    Ref&lt;RHI::IDescriptorSetLayout&gt; dlayout;
    Ref&lt;RHI::IDescriptorSet&gt; desc_set;
    Ref&lt;RHI::IShaderInputLayout&gt; slayout;
    Ref&lt;RHI::IPipelineState&gt; pso;
    Ref&lt;RHI::IResource&gt; rt_tex;
    Ref&lt;RHI::IRenderTargetView&gt; rtv;
    Ref&lt;RHI::IResource&gt; depth_tex;
    Ref&lt;RHI::IDepthStencilView&gt; dsv;
    Ref&lt;RHI::IResource&gt; vb;
    Ref&lt;RHI::IResource&gt; ib;
    Ref&lt;RHI::IResource&gt; cb;

    Ref&lt;RHI::IResource&gt; file_tex;

    f32 camera_rotation = 0.0f;

    RV init();
    RV update();
    bool is_exiting();
    RV resize(u32 width, u32 height);
};

DemoApp* g_app = nullptr;

struct Vertex
{
    Float3U position;
    Float2U texcoord;
};

RV DemoApp::init()
{
    lutry
    {
        luset(window, Window::new_window(&quot;DemoApp&quot;, Window::WindowDisplaySettings::as_windowed(), Window::WindowCreationFlag::resizable));
        window-&gt;get_close_event() += [](Window::IWindow* window) { window-&gt;close(); };
        window-&gt;get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) {
            lupanic_if_failed(g_app-&gt;resize(width, height));
        };

        dev = RHI::get_main_device();
        using namespace RHI;
        luset(queue, dev-&gt;new_command_queue(CommandQueueType::graphics));
        luset(cmdbuf, queue-&gt;new_command_buffer());
        luset(swap_chain, new_swap_chain(queue, window, SwapChainDesc(0, 0, 2, Format::rgba8_unorm, true)));

        luset(dlayout, dev-&gt;new_descriptor_set_layout(DescriptorSetLayoutDesc({
            {DescriptorType::cbv, 0, 1, ShaderVisibility::vertex},
            {DescriptorType::srv, 1, 1, ShaderVisibility::pixel},
            {DescriptorType::sampler, 2, 1, ShaderVisibility::pixel}
        })));
        luset(desc_set, dev-&gt;new_descriptor_set(DescriptorSetDesc(dlayout)));

        const char vs_shader_code[] = R&quot;(
        cbuffer vertexBuffer : register(b0)
        {
            float4x4 world_to_proj;
        };
        struct VS_INPUT
        {
            float3 position : POSITION;
            float2 texcoord : TEXCOORD;
        };
        struct PS_INPUT
        {
            float4 position : SV_POSITION;
            float2 texcoord : TEXCOORD;
        };
        PS_INPUT main(VS_INPUT input)
        {
            PS_INPUT output;
            output.position = mul(world_to_proj, float4(input.position, 1.0f));
            output.texcoord = input.texcoord;
            return output;
        })&quot;;

        const char ps_shader_code[] = R&quot;(
        Texture2D tex : register(t1);
        SamplerState tex_sampler : register(s2);
        struct PS_INPUT
        {
            float4 position : SV_POSITION;
            float2 texcoord : TEXCOORD;
        };
        float4 main(PS_INPUT input) : SV_Target
        {
            return float4(tex.Sample(tex_sampler, input.texcoord));
        })&quot;;
        auto compiler = ShaderCompiler::new_compiler();
        compiler-&gt;set_source({ vs_shader_code, strlen(vs_shader_code)});
        compiler-&gt;set_source_name(&quot;DemoAppVS&quot;);
        compiler-&gt;set_entry_point(&quot;main&quot;);
        compiler-&gt;set_target_format(RHI::get_current_platform_shader_target_format());
        compiler-&gt;set_shader_type(ShaderCompiler::ShaderType::vertex);
        compiler-&gt;set_shader_model(5, 0);
        compiler-&gt;set_optimization_level(ShaderCompiler::OptimizationLevel::full);
        luexp(compiler-&gt;compile());
        auto vs_data = compiler-&gt;get_output();
        Blob vs(vs_data.data(), vs_data.size());

        compiler-&gt;reset();
        compiler-&gt;set_source({ ps_shader_code, strlen(ps_shader_code)});
        compiler-&gt;set_source_name(&quot;DemoAppPS&quot;);
        compiler-&gt;set_entry_point(&quot;main&quot;);
        compiler-&gt;set_target_format(RHI::get_current_platform_shader_target_format());
        compiler-&gt;set_shader_type(ShaderCompiler::ShaderType::pixel);
        compiler-&gt;set_shader_model(5, 0);
        compiler-&gt;set_optimization_level(ShaderCompiler::OptimizationLevel::full);
        luexp(compiler-&gt;compile());
        auto ps_data = compiler-&gt;get_output();
        Blob ps(ps_data.data(), ps_data.size());

        luset(slayout, dev-&gt;new_shader_input_layout(ShaderInputLayoutDesc({dlayout}, 
            ShaderInputLayoutFlag::allow_input_assembler_input_layout |
            ShaderInputLayoutFlag::deny_hull_shader_access |
            ShaderInputLayoutFlag::deny_domain_shader_access |
            ShaderInputLayoutFlag::deny_geometry_shader_access)));
        GraphicsPipelineStateDesc ps_desc;
        ps_desc.primitive_topology_type = PrimitiveTopologyType::triangle;
        ps_desc.sample_mask = U32_MAX;
        ps_desc.sample_quality = 0;
        ps_desc.blend_state = BlendDesc(false, false, { RenderTargetBlendDesc(false, false, BlendFactor::src_alpha,
            BlendFactor::inv_src_alpha, BlendOp::add, BlendFactor::inv_src_alpha, BlendFactor::zero, BlendOp::add, LogicOp::noop, ColorWriteMask::all) });
        ps_desc.rasterizer_state = RasterizerDesc(FillMode::solid, CullMode::back, 0, 0.0f, 0.0f, 0, false, true, false, false, false);
        ps_desc.depth_stencil_state = DepthStencilDesc(true, true, ComparisonFunc::less_equal, false, 0x00, 0x00, DepthStencilOpDesc(), DepthStencilOpDesc());
        ps_desc.ib_strip_cut_value = IndexBufferStripCutValue::disabled;
        ps_desc.input_layout = InputLayoutDesc({
            {&quot;POSITION&quot;, 0, Format::rgb32_float},
            {&quot;TEXCOORD&quot;, 0, Format::rg32_float},
        });
        ps_desc.vs = vs.cspan();
        ps_desc.ps = ps.cspan();
        ps_desc.shader_input_layout = slayout;
        ps_desc.num_render_targets = 1;
        ps_desc.rtv_formats[0] = Format::rgba8_unorm;
        ps_desc.dsv_format = Format::d32_float;
        luset(pso, dev-&gt;new_graphics_pipeline_state(ps_desc));

        auto window_size = window-&gt;get_framebuffer_size();
        luset(rt_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, 
            ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, window_size.x, window_size.y, 1, 1)));
        luset(depth_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, 
            ResourceUsageFlag::depth_stencil, window_size.x, window_size.y, 1, 1)));
        luset(rtv, dev-&gt;new_render_target_view(rt_tex));
        luset(dsv, dev-&gt;new_depth_stencil_view(depth_tex));

        Vertex vertices[] = {
            {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, +0.5, -0.5}, {0.0, 0.0}},
            {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, -0.5, +0.5}, {1.0, 1.0}},

            {{+0.5, -0.5, +0.5}, {0.0, 1.0}}, {{+0.5, +0.5, +0.5}, {0.0, 0.0}},
            {{-0.5, +0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 1.0}},

            {{-0.5, -0.5, +0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}},
            {{-0.5, +0.5, -0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}},

            {{-0.5, -0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 0.0}},
            {{+0.5, +0.5, -0.5}, {1.0, 0.0}}, {{+0.5, -0.5, -0.5}, {1.0, 1.0}},

            {{-0.5, +0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}},
            {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 1.0}},

            {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 0.0}},
            {{-0.5, -0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}}
        };
        u32 indices[] = {
            0, 1, 2, 0, 2, 3, 
            4, 5, 6, 4, 6, 7, 
            8, 9, 10, 8, 10, 11,
            12, 13, 14, 12, 14, 15,
            16, 17, 18, 16, 18, 19,
            20, 21, 22, 20, 22, 23
        };
        luset(vb, dev-&gt;new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::vertex_buffer, sizeof(vertices))));
        luset(ib, dev-&gt;new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::index_buffer, sizeof(indices))));
        void* mapped = nullptr;
        luexp(vb-&gt;map_subresource(0, false, &amp;mapped));
        memcpy(mapped, vertices, sizeof(vertices));
        vb-&gt;unmap_subresource(0, true);
        luexp(ib-&gt;map_subresource(0, false, &amp;mapped));
        memcpy(mapped, indices, sizeof(indices));
        ib-&gt;unmap_subresource(0, true);
        auto cb_align = dev-&gt;get_constant_buffer_data_alignment();
        luset(cb, dev-&gt;new_resource(ResourceDesc::buffer(ResourceHeapType::upload, ResourceUsageFlag::constant_buffer, align_upper(sizeof(Float4x4), cb_align))));

        lulet(image_file, open_file(&quot;Luna.png&quot;, FileOpenFlag::read, FileCreationMode::open_existing));
        lulet(image_file_data, load_file_data(image_file));
        Image::ImageDesc image_desc;
        lulet(image_data, Image::read_image_file(image_file_data.data(), image_file_data.size(), Image::ImagePixelFormat::rgba8_unorm, image_desc));

        luset(file_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::shared_upload, Format::rgba8_unorm, 
            ResourceUsageFlag::shader_resource, image_desc.width, image_desc.height, 1, 1)));
        luexp(file_tex-&gt;map_subresource(0, false));
        luexp(file_tex-&gt;write_subresource(0, image_data.data(), 
            image_desc.width * Image::pixel_size(image_desc.format), 
            image_desc.width * image_desc.height * Image::pixel_size(image_desc.format), BoxU(0, 0, 0, image_desc.width, image_desc.height, 1)));
        file_tex-&gt;unmap_subresource(0, true);

        desc_set-&gt;set_cbv(0, cb, ConstantBufferViewDesc(0, align_upper(sizeof(Float4x4), cb_align)));
        desc_set-&gt;set_srv(1, file_tex);
        desc_set-&gt;set_sampler(2, SamplerDesc(FilterMode::min_mag_mip_linear, TextureAddressMode::clamp,
                TextureAddressMode::clamp, TextureAddressMode::clamp, 0.0f, 1, ComparisonFunc::always, 
                Float4U(0, 0, 0, 0), 0.0f, 0.0f));

    }
    lucatchret;
    return ok;
}
RV DemoApp::update()
{
    Window::poll_events();
    if(window-&gt;is_closed()) return ok;
    lutry
    {
        camera_rotation += 1.0f;
        Float3 camera_pos(cosf(camera_rotation / 180.0f * PI) * 2.0f, 1.0f, sinf(camera_rotation / 180.0f * PI) * 2.0f);
        Float4x4 camera_mat = AffineMatrix::make_look_at(camera_pos, Float3(0, 0, 0), Float3(0, 1, 0));
        auto window_sz = window-&gt;get_framebuffer_size();
        camera_mat = mul(camera_mat, ProjectionMatrix::make_perspective_fov(PI / 3.0f, (f32)window_sz.x / (f32)window_sz.y, 0.001f, 100.0f));
        void* camera_mapped;
        luexp(cb-&gt;map_subresource(0, false, &amp;camera_mapped));
        memcpy(camera_mapped, &amp;camera_mat, sizeof(Float4x4));
        cb-&gt;unmap_subresource(0, true);

        using namespace RHI;

        cmdbuf-&gt;resource_barriers({
            ResourceBarrierDesc::as_transition(cb, ResourceState::vertex_and_constant_buffer),
            ResourceBarrierDesc::as_transition(vb, ResourceState::vertex_and_constant_buffer),
            ResourceBarrierDesc::as_transition(ib, ResourceState::index_buffer),
            ResourceBarrierDesc::as_transition(file_tex, ResourceState::shader_resource_pixel),
            ResourceBarrierDesc::as_transition(rt_tex, ResourceState::render_target),
            ResourceBarrierDesc::as_transition(depth_tex, ResourceState::depth_stencil_write)
        });

        RenderPassDesc desc;
        desc.rtvs[0] = rtv;
        desc.rt_load_ops[0] = LoadOp::clear;
        desc.rt_store_ops[0] = StoreOp::store;
        desc.rt_clear_values[0] = {0, 0, 0, 0};
        desc.dsv = dsv;
        desc.depth_load_op = LoadOp::clear;
        desc.depth_store_op = StoreOp::store;
        desc.depth_clear_value = 1.0f;
        desc.stencil_load_op = LoadOp::dont_care;
        desc.stencil_store_op = StoreOp::dont_care;
        cmdbuf-&gt;begin_render_pass(desc);
        cmdbuf-&gt;set_graphics_shader_input_layout(slayout);
        cmdbuf-&gt;set_pipeline_state(pso);
        cmdbuf-&gt;set_graphics_descriptor_set(0, desc_set);
        cmdbuf-&gt;set_primitive_topology(PrimitiveTopology::triangle_list);
        auto sz = vb-&gt;get_desc().width_or_buffer_size;
        cmdbuf-&gt;set_vertex_buffers(0, {VertexBufferViewDesc(vb, 0, sz, sizeof(Vertex))});
        sz = ib-&gt;get_desc().width_or_buffer_size;
        cmdbuf-&gt;set_index_buffer(IndexBufferViewDesc(ib, 0, sz, Format::r32_uint));
        cmdbuf-&gt;set_scissor_rect(RectI(0, 0, (i32)window_sz.x, (i32)window_sz.y));
        cmdbuf-&gt;set_viewport(Viewport(0.0f, 0.0f, (f32)window_sz.x, (f32)window_sz.y, 0.0f, 1.0f));
        cmdbuf-&gt;draw_indexed(36, 0, 0);
        cmdbuf-&gt;end_render_pass();

        luexp(cmdbuf-&gt;submit());
        luexp(swap_chain-&gt;present(rt_tex, 0));
        swap_chain-&gt;wait();
        luexp(cmdbuf-&gt;reset());
    }
    lucatchret;
    return ok;
}
bool DemoApp::is_exiting()
{
    return window-&gt;is_closed();
}
RV DemoApp::resize(u32 width, u32 height)
{
    lutry
    {
        using namespace RHI;
        auto dev = get_main_device();
        luexp(swap_chain-&gt;reset({width, height, 2, Format::rgba8_unorm, true}));
        luset(rt_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, 
            ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, width, height, 1, 1)));
        luset(depth_tex, dev-&gt;new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, 
            ResourceUsageFlag::depth_stencil, width, height, 1, 1)));
        luset(rtv, dev-&gt;new_render_target_view(rt_tex));
        luset(dsv, dev-&gt;new_depth_stencil_view(depth_tex));
    }
    lucatchret;
    return ok;
}
RV run_app()
{
    auto result = init_modules();
    if(failed(result)) return result;
    g_app = memnew&lt;DemoApp&gt;();
    result = g_app-&gt;init();
    if(failed(result)) return result;
    while(!g_app-&gt;is_exiting())
    {
        result = g_app-&gt;update();
        if(failed(result)) return result;
    }
    return ok;
}
int main()
{
    bool initialized = Luna::init();
    if(!initialized) return -1;
    RV result = run_app();
    if(failed(result)) debug_printf(explain(result.errcode()));
    if(g_app) memdelete(g_app);
    Luna::close();
    return 0;
}
</code></pre>
<h2 id="reference-code-for-xmakelua">Reference code for <code>xmake.lua</code></h2>
<pre><code class="language-lua">target(&quot;DemoApp&quot;)
    set_luna_sdk_program()
    add_headerfiles(&quot;**.hpp&quot;)
    add_files(&quot;**.cpp&quot;)
    add_deps(&quot;Runtime&quot;, &quot;Window&quot;, &quot;RHI&quot;, &quot;ShaderCompiler&quot;, &quot;Image&quot;)
    before_build(function(target)
        os.cp(&quot;$(scriptdir)/luna.png&quot;, target:targetdir() .. &quot;/luna.png&quot;)
    end)
    after_install(function (target)
        os.cp(target:targetdir() .. &quot;/luna.png&quot;, target:installdir() .. &quot;/bin/luna.png&quot;)
    end)
target_end()
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../" class="btn btn-neutral float-left" title="Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../basics/" class="btn btn-neutral float-right" title="Basics">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../basics/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme_extra.js" defer></script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
