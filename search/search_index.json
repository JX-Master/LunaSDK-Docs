{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Luna SDK Docs Welcome to Luna SDK Documentation Site.","title":"Home"},{"location":"#luna-sdk-docs","text":"Welcome to Luna SDK Documentation Site.","title":"Luna SDK Docs"},{"location":"manual/basics/","text":"Basics This chapter describes basic concepts and features that the user should understand in order to use Luna SDK correctly and efficiently. All feathers described in this chapter are provided by the Runtime module of Luna SDK, which is the base module of Luna SDK and is included by all other modules implicitly.","title":"Basics"},{"location":"manual/basics/#basics","text":"This chapter describes basic concepts and features that the user should understand in order to use Luna SDK correctly and efficiently. All feathers described in this chapter are provided by the Runtime module of Luna SDK, which is the base module of Luna SDK and is included by all other modules implicitly.","title":"Basics"},{"location":"manual/basics/basic_types/","text":"Basic Types Primitive types The following table lists all primitive typed designed by Luna SDK. Type Description C++ STD Equivalent u8 Unsigned 8-bit integer. std::uint8_t i8 Signed 8-bit integer. std::int8_t u16 Unsigned 16-bit integer. std::uint16_t i16 Signed 16-bit integer. std::int16_t u32 Unsigned 32-bit integer. std::uint32_t i32 Signed 32-bit integer. std::int32_t u64 Unsigned 64-bit integer. std::uint64_t i64 Signed 64-bit integer. std::int64_t usize Unsigned machine-sized integer. std::size_t isize Signed machine-sized integer. std::ptrdiff_t f32 32-bit floating-point number. float f64 64-bit floating-point number. double c8 8-bit character. char c16 16-bit character. chat16_t c32 32-bit character. char32_t Aliasing types of primitive types byte_t is an aliasing type of u8 that indicates one byte. You should use byte_t instead of u8 if you want to be clear that you are talking about bytes, not numbers, for example, in a binary stream ( byte_t* ). opaque_t is an aliasing type of void* that indicated one opaque pointer that should not be dereferenced by the user. Such pointers are usually used as handles to internal data structures, the user should pass opaque_t to functions provided by the system to manipulate it. InitializerList<T> is an aliasing type of std::initializer_list<_Ty> in Luna SDK. VarList is an aliasing type of va_list in Luna SDK. Containers #include <Runtime/Vector.hpp> #include <Runtime/List.hpp> #include <Runtime/HashMap.hpp> #include <Runtime/HashSet.hpp> #include <Runtime/UnorderedMap.hpp> #include <Runtime/UnorderedSet.hpp> #include <Runtime/UnorderedMultiMap.hpp> #include <Runtime/UnorderedMultiSet.hpp> #include <Runtime/SelfIndexedHashMap.hpp> #include <Runtime/SelfIndexedUnorderedMap.hpp> #include <Runtime/SelfIndexedUnorderedMultiMap.hpp> #include <Runtime/RingDeque.hpp> For compatibility and cross-platform consistency reasons, Luna SDK does not use C++ Standard Template Library (STD), but implements its own container types using APIs similar to those of STD. The following table lists all containers provided by Luna SDK. Container Type Description C++ STD Equivalent Vector<T> Dynamic array type. std::vector<T> List<T> Dynamic double-linked list type. std::list<T> HashMap<K, V> Closed hash map type using Robinhood Hashing. N/A HashSet<V> Closed hash set type using Robinhood Hashing. N/A UnorderedMap<K, V> Open hash map type. std::unordered_map<K, V> UnorderedSet<V> Open hash set type. std::unordered_set<V> UnorderedMultiMap<K, V> Open hash map type that allows elements with the same key. std::unordered_multimap<K, V> UnorderedMultiSet<V> Open hash map type that allows multiple insertions of the same elements. std::unordered_multiset<K, V> SelfIndexedHashMap<K, V, E> Closed hash map whose key type can be extracted from the value type. N/A SelfIndexedUnorderedMap<K, V, E> Open hash map whose key type can be extracted from the value type. N/A SelfIndexedUnorderedMultiMap<K, V, E> Open hash map whose key type can be extracted from the value type, and allows multiple insertions of the same elements. N/A RingDeque<T> Double-ended queue using ring buffering. std::deque<T> Self indexed map containers Self indexed map containers are used for elements whose key is a part of the value object. For example, given the following structure: struct Player { Name name; i32 hp; i32 mp; }; Now we want to use one map to store all player records using their name as the key. If we use normal HashMap or UnorderedMap container, every entry in the container will be saved as Pair<const Name, Player> , thus stores the player name twice. In such case, we can use SelfIndexedHashMap and SelfIndexedUnorderedMap instead. The self indexed hash map container does not store the key object directly, instead, it requires the user to provide a special functional object E , which will be called when the key is needed. The functional object E takes a reference to the value object of the map element, and should returns a value or reference to the key object of the element. In our example, we can implement E as below: struct PlayerExtractKey { const Name& operator()(const Player& val) const { return val.name; } }; Then we can define the self indexed map like so: #include <Runtime/SelfIndexedHashMap.hpp> namespace Luna { SelfIndexedHashMap<Name, Player, PlayerExtractKey> players; } When using self indexed map containers, the user must ensure that the key object is immutable for all elements in the container, or the behavior is undefined. BLOB #include <Runtime/Blob.hpp> BLOB refers to Binary Large OBject, which is a memory block with arbitrary data. In Luna SDK, we use Blob structure to represent one BLOB object. Blob can be used in many ways, but the common use for it is to store and transfer binary data. For example, load_file_data function returns a Blob object, which contains the data of the file. Span #include <Runtime/Span.hpp> Span is a template type that refers to one continuous sequence of instances. There are two types of spans in Luna SDK: fixed span and variable span. Fixed spans are spans whose size is decided at compile time, and cannot be changed. Such span only requires one pointer to the object range to be well defined, and the number of elements in the span should be declared as part of the type: i32 data[] = {3, 4, 5, 6, 7}; Span<i32, 3> range(data + 1); debug_printf(\"%d\", range.size()); // 3 for (i32 i : range) debug_printf(\"%d, \", i); // 4, 5, 6, range = Span<i32, 3>(data + 2); debug_printf(\"%d\", range.size()); // 3 for (i32 i : range) debug_printf(\"%d, \", i); // 5, 6, 7, Variable spans are spans whose size may change at run time. Such span requires both the pointer to the object range and the size of the range to be well defined: i32 data[] = {3, 4, 5, 6, 7}; Span<i32> range(data + 1), 3; debug_printf(\"%d\", range.size()); // 3 for (i32 i : range) debug_printf(\"%d, \", i); // 4, 5, 6, range = Span<i32>(data + 2, 2); debug_printf(\"%d\", range.size()); // 2 for (i32 i : range) debug_printf(\"%d, \", i); // 5, 6, Note that spans are NOT containers, they don't allocate memory to store the data, only stores pointers to the objects provided by the user. So use spans only when the original object sequence is valid. Prefer using Span<T> instead of C-style pointer and size pair when referring memory ranges. GUID #include <Runtime/Base.hpp> Globally Unique Identifier (GUID) is a algorithm-generated 128-bit integer identifier. In Luna SDK, GUIDs are represented by Guid type: struct Guid { u64 high; u64 low; }; Luna SDK supports generating GUID instances from the registry form ( xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx or {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} ) at compile time: constexpr Guid test_id(\"{5cf28858-60b0-49f2-9674-5888fa7ad027}\"); static_assert(test_id.low == 10841387548328775719Ui64, \"Incorrect GUID values.\"); static_assert(test_id.high == 6697565509014014450Ui64, \"Incorrect GUID values.\"); GUIDs are used widely in Luna SDK for identifying assets, types, interfaces, objects and many other entities. Version type #include <Runtime/Base.hpp> Version represent the version of one application, module or any version-controlled entity. Every version is composed by three numbers: major , minor and patch : struct Version { u32 major; u32 minor; u32 patch; }; We suggest using the following rules to manage the version number: An increment of major version indicates a breaking change to the interface of the entity, so that existing codes, programs and services using the entity must be explicitly modified to use the newer version of the entity correctly. An increment of minor version indicates a non-breaking change to the interface of the entity, so that existing codes, programs and services can use the newer version of the entity correctly without any source-level modification. An increment of patch version indicates a internal change of the entity and should not affect the entity interface, so that existing codes, programs and services can use the newer version of the entity correctly without any source-level modification. Pair and tuple types #include <Runtime/Base.hpp> // For Pair. #include <Runtime/Tuple.hpp> // For Tuple. Pair<T1, T2> encapsulates one pair of elements with T1 and T2 type as the first and second element of the pair. Pair is mainly used by map containers to represent elements. Tuple<Tys...> is a generalization of Pair and may contain one or multiple elements. Elements in Tuple can be fetched by calling get<N>(tuple) function. This type is mainly used to store function arguments in functional programming.","title":"Basic Types"},{"location":"manual/basics/basic_types/#basic-types","text":"","title":"Basic Types"},{"location":"manual/basics/basic_types/#primitive-types","text":"The following table lists all primitive typed designed by Luna SDK. Type Description C++ STD Equivalent u8 Unsigned 8-bit integer. std::uint8_t i8 Signed 8-bit integer. std::int8_t u16 Unsigned 16-bit integer. std::uint16_t i16 Signed 16-bit integer. std::int16_t u32 Unsigned 32-bit integer. std::uint32_t i32 Signed 32-bit integer. std::int32_t u64 Unsigned 64-bit integer. std::uint64_t i64 Signed 64-bit integer. std::int64_t usize Unsigned machine-sized integer. std::size_t isize Signed machine-sized integer. std::ptrdiff_t f32 32-bit floating-point number. float f64 64-bit floating-point number. double c8 8-bit character. char c16 16-bit character. chat16_t c32 32-bit character. char32_t","title":"Primitive types"},{"location":"manual/basics/basic_types/#aliasing-types-of-primitive-types","text":"byte_t is an aliasing type of u8 that indicates one byte. You should use byte_t instead of u8 if you want to be clear that you are talking about bytes, not numbers, for example, in a binary stream ( byte_t* ). opaque_t is an aliasing type of void* that indicated one opaque pointer that should not be dereferenced by the user. Such pointers are usually used as handles to internal data structures, the user should pass opaque_t to functions provided by the system to manipulate it. InitializerList<T> is an aliasing type of std::initializer_list<_Ty> in Luna SDK. VarList is an aliasing type of va_list in Luna SDK.","title":"Aliasing types of primitive types"},{"location":"manual/basics/basic_types/#containers","text":"#include <Runtime/Vector.hpp> #include <Runtime/List.hpp> #include <Runtime/HashMap.hpp> #include <Runtime/HashSet.hpp> #include <Runtime/UnorderedMap.hpp> #include <Runtime/UnorderedSet.hpp> #include <Runtime/UnorderedMultiMap.hpp> #include <Runtime/UnorderedMultiSet.hpp> #include <Runtime/SelfIndexedHashMap.hpp> #include <Runtime/SelfIndexedUnorderedMap.hpp> #include <Runtime/SelfIndexedUnorderedMultiMap.hpp> #include <Runtime/RingDeque.hpp> For compatibility and cross-platform consistency reasons, Luna SDK does not use C++ Standard Template Library (STD), but implements its own container types using APIs similar to those of STD. The following table lists all containers provided by Luna SDK. Container Type Description C++ STD Equivalent Vector<T> Dynamic array type. std::vector<T> List<T> Dynamic double-linked list type. std::list<T> HashMap<K, V> Closed hash map type using Robinhood Hashing. N/A HashSet<V> Closed hash set type using Robinhood Hashing. N/A UnorderedMap<K, V> Open hash map type. std::unordered_map<K, V> UnorderedSet<V> Open hash set type. std::unordered_set<V> UnorderedMultiMap<K, V> Open hash map type that allows elements with the same key. std::unordered_multimap<K, V> UnorderedMultiSet<V> Open hash map type that allows multiple insertions of the same elements. std::unordered_multiset<K, V> SelfIndexedHashMap<K, V, E> Closed hash map whose key type can be extracted from the value type. N/A SelfIndexedUnorderedMap<K, V, E> Open hash map whose key type can be extracted from the value type. N/A SelfIndexedUnorderedMultiMap<K, V, E> Open hash map whose key type can be extracted from the value type, and allows multiple insertions of the same elements. N/A RingDeque<T> Double-ended queue using ring buffering. std::deque<T>","title":"Containers"},{"location":"manual/basics/basic_types/#self-indexed-map-containers","text":"Self indexed map containers are used for elements whose key is a part of the value object. For example, given the following structure: struct Player { Name name; i32 hp; i32 mp; }; Now we want to use one map to store all player records using their name as the key. If we use normal HashMap or UnorderedMap container, every entry in the container will be saved as Pair<const Name, Player> , thus stores the player name twice. In such case, we can use SelfIndexedHashMap and SelfIndexedUnorderedMap instead. The self indexed hash map container does not store the key object directly, instead, it requires the user to provide a special functional object E , which will be called when the key is needed. The functional object E takes a reference to the value object of the map element, and should returns a value or reference to the key object of the element. In our example, we can implement E as below: struct PlayerExtractKey { const Name& operator()(const Player& val) const { return val.name; } }; Then we can define the self indexed map like so: #include <Runtime/SelfIndexedHashMap.hpp> namespace Luna { SelfIndexedHashMap<Name, Player, PlayerExtractKey> players; } When using self indexed map containers, the user must ensure that the key object is immutable for all elements in the container, or the behavior is undefined.","title":"Self indexed map containers"},{"location":"manual/basics/basic_types/#blob","text":"#include <Runtime/Blob.hpp> BLOB refers to Binary Large OBject, which is a memory block with arbitrary data. In Luna SDK, we use Blob structure to represent one BLOB object. Blob can be used in many ways, but the common use for it is to store and transfer binary data. For example, load_file_data function returns a Blob object, which contains the data of the file.","title":"BLOB"},{"location":"manual/basics/basic_types/#span","text":"#include <Runtime/Span.hpp> Span is a template type that refers to one continuous sequence of instances. There are two types of spans in Luna SDK: fixed span and variable span. Fixed spans are spans whose size is decided at compile time, and cannot be changed. Such span only requires one pointer to the object range to be well defined, and the number of elements in the span should be declared as part of the type: i32 data[] = {3, 4, 5, 6, 7}; Span<i32, 3> range(data + 1); debug_printf(\"%d\", range.size()); // 3 for (i32 i : range) debug_printf(\"%d, \", i); // 4, 5, 6, range = Span<i32, 3>(data + 2); debug_printf(\"%d\", range.size()); // 3 for (i32 i : range) debug_printf(\"%d, \", i); // 5, 6, 7, Variable spans are spans whose size may change at run time. Such span requires both the pointer to the object range and the size of the range to be well defined: i32 data[] = {3, 4, 5, 6, 7}; Span<i32> range(data + 1), 3; debug_printf(\"%d\", range.size()); // 3 for (i32 i : range) debug_printf(\"%d, \", i); // 4, 5, 6, range = Span<i32>(data + 2, 2); debug_printf(\"%d\", range.size()); // 2 for (i32 i : range) debug_printf(\"%d, \", i); // 5, 6, Note that spans are NOT containers, they don't allocate memory to store the data, only stores pointers to the objects provided by the user. So use spans only when the original object sequence is valid. Prefer using Span<T> instead of C-style pointer and size pair when referring memory ranges.","title":"Span"},{"location":"manual/basics/basic_types/#guid","text":"#include <Runtime/Base.hpp> Globally Unique Identifier (GUID) is a algorithm-generated 128-bit integer identifier. In Luna SDK, GUIDs are represented by Guid type: struct Guid { u64 high; u64 low; }; Luna SDK supports generating GUID instances from the registry form ( xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx or {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} ) at compile time: constexpr Guid test_id(\"{5cf28858-60b0-49f2-9674-5888fa7ad027}\"); static_assert(test_id.low == 10841387548328775719Ui64, \"Incorrect GUID values.\"); static_assert(test_id.high == 6697565509014014450Ui64, \"Incorrect GUID values.\"); GUIDs are used widely in Luna SDK for identifying assets, types, interfaces, objects and many other entities.","title":"GUID"},{"location":"manual/basics/basic_types/#version-type","text":"#include <Runtime/Base.hpp> Version represent the version of one application, module or any version-controlled entity. Every version is composed by three numbers: major , minor and patch : struct Version { u32 major; u32 minor; u32 patch; }; We suggest using the following rules to manage the version number: An increment of major version indicates a breaking change to the interface of the entity, so that existing codes, programs and services using the entity must be explicitly modified to use the newer version of the entity correctly. An increment of minor version indicates a non-breaking change to the interface of the entity, so that existing codes, programs and services can use the newer version of the entity correctly without any source-level modification. An increment of patch version indicates a internal change of the entity and should not affect the entity interface, so that existing codes, programs and services can use the newer version of the entity correctly without any source-level modification.","title":"Version type"},{"location":"manual/basics/basic_types/#pair-and-tuple-types","text":"#include <Runtime/Base.hpp> // For Pair. #include <Runtime/Tuple.hpp> // For Tuple. Pair<T1, T2> encapsulates one pair of elements with T1 and T2 type as the first and second element of the pair. Pair is mainly used by map containers to represent elements. Tuple<Tys...> is a generalization of Pair and may contain one or multiple elements. Elements in Tuple can be fetched by calling get<N>(tuple) function. This type is mainly used to store function arguments in functional programming.","title":"Pair and tuple types"},{"location":"manual/basics/coding_convention/","text":"Coding Convention This section discusses the coding conventions used in Luna SDK. All users using Luna SDK should follow these conventions to achieve a consistent code style and prevent programming errors. Disabled C++ features The following C++ features are disabled in Luna SDK: Exceptions ( try , throw , catch ). Real-time type identification (RTTI, dynamic_cast and typeid for objects). The use of typeid for static types is allowed. In rare cases, if you have to use these features (like integrating one third-party library that uses these features), make sure these features are used internally in your module, and not cross the module interface, or they may not be handled correctly. The noexcept decorator is not used in Luna SDK, since exceptions are disabled by default. File naming conventions Use .hpp file extension name for C++ header files, use .cpp file extension name for C++ source files, use .inl file extension name for inlined C++ source files. Use Pascal case for file and folder names, like FileIterator.hpp . Do not add interface prefix I to the filename. Add the following comments at the beginning of every C++ header, source or inlined source file if you want to contribute it as part of Luna SDK. /*! * This file is a portion of Luna SDK. * For conditions of distribution and use, see the disclaimer * and license in LICENSE.txt * * @file {The filename of this file} * @author {Author name} * @date {The file creation date, YYYY/MM/DD} */ Lexical formats Indents One indent can be represented by one tab character or four whitespace characters. Both forms are allowed. Scopes In most cases, scope opening and closing brackets should occupy a whole line. Nested scopes should be properly indented. namesapce A { namespace B { class C { }; } } However, if the scope is empty or contains simple statements, you may write the opening and coding brackets without beginning a new line: class A { i32 n; public: A() {} // Empty scope. i32 get_n() { return n; } // Simple scope. } Always use the form that maximizes the readability when deciding scoping forms. Documenting comments Use doxygen comment blocks for documenting comments (comments that exists in the header file as the documentation of function, type or object). //! Resets the task context and begins a new task. //! @param[in] world The world to run the task on. //! @param[in] exec_mode The task execution mode. //! @param[in] read_components If task mode is `shared`, specify components that will be read by this task. //! @param[in] write_components If task mode is `shared`, specify components that will be read and written by //! this task. //! @remark This call may block the current thread until all components required by this task can be safely //! accessed by this task, or until all other tasks are finished if this is a exclusive task. virtual void begin( IWorld* world, TaskExecutionMode exec_mode, Span<typeinfo_t> read_components, Span<typeinfo_t> write_components ) = 0; Naming conventions Primitive types Primitive types (numbers, characters, pointers) and the aliasing primitive types are named using the underscore case: u8 i32 usize For all user-defined aliasing types of primitive types, uses _t suffix: using opaque_t = void* Enumeration types Use enum classs instead of enum for all enumerations. All enumeration types are named using the Pascal case. Options of the enumeration are named using the underscore case. enum class ResourceType : u8 { buffer, texture_1d, texture_2d, texture_3d }; If the enumeration represents a single-value type, the use of Type or Kind suffix is suggested, but not required; if the enumeration represents a bit-OR-combined multi-value type, the use of Flag suffix is suggested, but not required. For all multi-value enumeration types, always provides one option none with the value 0 . Using hexadecimal form to represent multi-value enumeration option values is suggested, but not required. enum class ResourceUsageFlag : u32 { none = 0x00, shader_resource = 0x01, constant_buffer = 0x02, unordered_access = 0x04, render_target = 0x08, depth_stencil = 0x10, vertex_buffer = 0x20, index_buffer = 0x40, stream_output = 0x80, indirect_buffer = 0x100, }; Structure and class types Types defined by struct and class are considered the same in Luna SDK, we use \"structure type\" to refer both. Most structure types are named using the Pascal case. struct ResourceDesc { ResourceType type; ResourceHeapType heap_type; Format pixel_format; ResourceUsageFlag usages; u64 width_or_buffer_size; u32 height; u32 depth_or_array_size; u32 mip_levels; u32 sample_count; u32 sample_quality; ResourceFlag flags; }; The only exception is the structure type that: contains only one primitive typed member object. can be trivially constructed, destructed, copied and moved. can be constructed by providing one value with the same type of its member variable, and the behavior is assigning its member object with the provided value. In such case, we consider the structure type as a aliasing type of the primitive type, thus use the underscore case with _t suffix for the type: struct asset_t { opaque_t handle; asset_t() : handle(nullptr) {} constexpr asset_t(opaque_t handle) : handle(handle) {} constexpr bool operator==(const asset_t& rhs) const { return handle == rhs.handle; } constexpr bool operator!=(const asset_t& rhs) const { return handle != rhs.handle; } operator bool() const { return handle != nullptr; } }; Note that using the Pascal case for such structure type is also allowed. Interface structure types If the structure type represents an interface, append I prefix to the structure type name. struct IStream : virtual Interface { luiid(\"{0345f636-ca5c-4b4d-8416-29834377d239}\"); virtual RV read(void* buffer, usize size, usize* read_bytes = nullptr) = 0; virtual RV write(const void* buffer, usize size, usize* write_bytes = nullptr) = 0; }; Functions All functions, including member functions of structure types, are named using the underscore case. Function parameters are also named using the underscore case. RV read_file(opaque_t file, void* buffer, usize size, usize* read_bytes = nullptr); For functions with long parameter lists, you can separate parameter lists into multiple lines, providing the parameter list line is correctly indented. void draw_shape(u32 begin_command, u32 num_commands, const Float2U& min_position, const Float2U& max_position, const Float2U& min_shapecoord, const Float2U& max_shapecoord, u32 color = 0xFFFFFFFF, const Float2U& min_texcoord = Float2U(0.0f), const Float2U& max_texcoord = Float2U(0.0f)); These rules are also applied to member functions. Objects All objects except global constants are named using the underscore case, including member object of structure types. Float2U origin_point; For member objects of structure types that are not exposed as part of module interface, the prefix m_ is suggested, but not required. struct ComponentBuffer { typeinfo_t m_type; void* m_data = nullptr; usize m_size = 0; usize m_capacity = 0; }; For global variables that are not exposed as part of module interface, the prefix g_ is suggested, but not required. Ref<IFontFile> g_default_font; Global constants are named using uppercase words separated by underscores, and is decorated by constexpr . constexpr f32 PI = 3.141592654f; constexpr entity_id_t NULL_ENTITY(0); Prevent defining global constants using macros. Namespace All namespaces are named using the Pascal case. namespace Luna { namespace RHI { } } All Luna SDK components are defined in Luna namespace, every Luna SDK module except Runtime should have its own namespace under Luna containing its own components. Macros Macros can be declared using two forms. The first form is uppercase words separated by underscores, with LUNA_ prefix. These macros are usually used for conditional compiling and replacing some platform-dependent keywords. #define LUNA_DEBUG 1 #define LUNA_PROFILE 1 #define LUNA_RELEASE 1 #if defined(LUNA_COMPILER_MSVC) #define LUNA_DLL_EXPORT __declspec(dllexport) #else #define LUNA_DLL_EXPORT __attribute__ ((visibility(\"default\"))) #endif The second form is the underscore case with lu prefix. These macros are usually used to replace some code patterns to improve coding efficiency. #define luassert(_condition) //... #define luassert_msg(_condition, _message) //... #define lustruct(_name, _guid) //... #define luproperty(_struct, _type, _name) //... #define luenum(_type, _name, _guid) //... #define luoption(_enum, _item) //... #define lucatchret //... Macro parameters are allowed for both macro forms. Macro parameter names should be prefixed with one underscore character. Templates Template type parameters should be decorated with typename instead of class , and should be prefixed with one underscore character. template <typename _Ty> struct less { constexpr bool operator()(const _Ty& lhs, const _Ty& rhs) const { return lhs < rhs; } };","title":"Coding Convention"},{"location":"manual/basics/coding_convention/#coding-convention","text":"This section discusses the coding conventions used in Luna SDK. All users using Luna SDK should follow these conventions to achieve a consistent code style and prevent programming errors.","title":"Coding Convention"},{"location":"manual/basics/coding_convention/#disabled-c-features","text":"The following C++ features are disabled in Luna SDK: Exceptions ( try , throw , catch ). Real-time type identification (RTTI, dynamic_cast and typeid for objects). The use of typeid for static types is allowed. In rare cases, if you have to use these features (like integrating one third-party library that uses these features), make sure these features are used internally in your module, and not cross the module interface, or they may not be handled correctly. The noexcept decorator is not used in Luna SDK, since exceptions are disabled by default.","title":"Disabled C++ features"},{"location":"manual/basics/coding_convention/#file-naming-conventions","text":"Use .hpp file extension name for C++ header files, use .cpp file extension name for C++ source files, use .inl file extension name for inlined C++ source files. Use Pascal case for file and folder names, like FileIterator.hpp . Do not add interface prefix I to the filename. Add the following comments at the beginning of every C++ header, source or inlined source file if you want to contribute it as part of Luna SDK. /*! * This file is a portion of Luna SDK. * For conditions of distribution and use, see the disclaimer * and license in LICENSE.txt * * @file {The filename of this file} * @author {Author name} * @date {The file creation date, YYYY/MM/DD} */","title":"File naming conventions"},{"location":"manual/basics/coding_convention/#lexical-formats","text":"","title":"Lexical formats"},{"location":"manual/basics/coding_convention/#indents","text":"One indent can be represented by one tab character or four whitespace characters. Both forms are allowed.","title":"Indents"},{"location":"manual/basics/coding_convention/#scopes","text":"In most cases, scope opening and closing brackets should occupy a whole line. Nested scopes should be properly indented. namesapce A { namespace B { class C { }; } } However, if the scope is empty or contains simple statements, you may write the opening and coding brackets without beginning a new line: class A { i32 n; public: A() {} // Empty scope. i32 get_n() { return n; } // Simple scope. } Always use the form that maximizes the readability when deciding scoping forms.","title":"Scopes"},{"location":"manual/basics/coding_convention/#documenting-comments","text":"Use doxygen comment blocks for documenting comments (comments that exists in the header file as the documentation of function, type or object). //! Resets the task context and begins a new task. //! @param[in] world The world to run the task on. //! @param[in] exec_mode The task execution mode. //! @param[in] read_components If task mode is `shared`, specify components that will be read by this task. //! @param[in] write_components If task mode is `shared`, specify components that will be read and written by //! this task. //! @remark This call may block the current thread until all components required by this task can be safely //! accessed by this task, or until all other tasks are finished if this is a exclusive task. virtual void begin( IWorld* world, TaskExecutionMode exec_mode, Span<typeinfo_t> read_components, Span<typeinfo_t> write_components ) = 0;","title":"Documenting comments"},{"location":"manual/basics/coding_convention/#naming-conventions","text":"","title":"Naming conventions"},{"location":"manual/basics/coding_convention/#primitive-types","text":"Primitive types (numbers, characters, pointers) and the aliasing primitive types are named using the underscore case: u8 i32 usize For all user-defined aliasing types of primitive types, uses _t suffix: using opaque_t = void*","title":"Primitive types"},{"location":"manual/basics/coding_convention/#enumeration-types","text":"Use enum classs instead of enum for all enumerations. All enumeration types are named using the Pascal case. Options of the enumeration are named using the underscore case. enum class ResourceType : u8 { buffer, texture_1d, texture_2d, texture_3d }; If the enumeration represents a single-value type, the use of Type or Kind suffix is suggested, but not required; if the enumeration represents a bit-OR-combined multi-value type, the use of Flag suffix is suggested, but not required. For all multi-value enumeration types, always provides one option none with the value 0 . Using hexadecimal form to represent multi-value enumeration option values is suggested, but not required. enum class ResourceUsageFlag : u32 { none = 0x00, shader_resource = 0x01, constant_buffer = 0x02, unordered_access = 0x04, render_target = 0x08, depth_stencil = 0x10, vertex_buffer = 0x20, index_buffer = 0x40, stream_output = 0x80, indirect_buffer = 0x100, };","title":"Enumeration types"},{"location":"manual/basics/coding_convention/#structure-and-class-types","text":"Types defined by struct and class are considered the same in Luna SDK, we use \"structure type\" to refer both. Most structure types are named using the Pascal case. struct ResourceDesc { ResourceType type; ResourceHeapType heap_type; Format pixel_format; ResourceUsageFlag usages; u64 width_or_buffer_size; u32 height; u32 depth_or_array_size; u32 mip_levels; u32 sample_count; u32 sample_quality; ResourceFlag flags; }; The only exception is the structure type that: contains only one primitive typed member object. can be trivially constructed, destructed, copied and moved. can be constructed by providing one value with the same type of its member variable, and the behavior is assigning its member object with the provided value. In such case, we consider the structure type as a aliasing type of the primitive type, thus use the underscore case with _t suffix for the type: struct asset_t { opaque_t handle; asset_t() : handle(nullptr) {} constexpr asset_t(opaque_t handle) : handle(handle) {} constexpr bool operator==(const asset_t& rhs) const { return handle == rhs.handle; } constexpr bool operator!=(const asset_t& rhs) const { return handle != rhs.handle; } operator bool() const { return handle != nullptr; } }; Note that using the Pascal case for such structure type is also allowed.","title":"Structure and class types"},{"location":"manual/basics/coding_convention/#interface-structure-types","text":"If the structure type represents an interface, append I prefix to the structure type name. struct IStream : virtual Interface { luiid(\"{0345f636-ca5c-4b4d-8416-29834377d239}\"); virtual RV read(void* buffer, usize size, usize* read_bytes = nullptr) = 0; virtual RV write(const void* buffer, usize size, usize* write_bytes = nullptr) = 0; };","title":"Interface structure types"},{"location":"manual/basics/coding_convention/#functions","text":"All functions, including member functions of structure types, are named using the underscore case. Function parameters are also named using the underscore case. RV read_file(opaque_t file, void* buffer, usize size, usize* read_bytes = nullptr); For functions with long parameter lists, you can separate parameter lists into multiple lines, providing the parameter list line is correctly indented. void draw_shape(u32 begin_command, u32 num_commands, const Float2U& min_position, const Float2U& max_position, const Float2U& min_shapecoord, const Float2U& max_shapecoord, u32 color = 0xFFFFFFFF, const Float2U& min_texcoord = Float2U(0.0f), const Float2U& max_texcoord = Float2U(0.0f)); These rules are also applied to member functions.","title":"Functions"},{"location":"manual/basics/coding_convention/#objects","text":"All objects except global constants are named using the underscore case, including member object of structure types. Float2U origin_point; For member objects of structure types that are not exposed as part of module interface, the prefix m_ is suggested, but not required. struct ComponentBuffer { typeinfo_t m_type; void* m_data = nullptr; usize m_size = 0; usize m_capacity = 0; }; For global variables that are not exposed as part of module interface, the prefix g_ is suggested, but not required. Ref<IFontFile> g_default_font; Global constants are named using uppercase words separated by underscores, and is decorated by constexpr . constexpr f32 PI = 3.141592654f; constexpr entity_id_t NULL_ENTITY(0); Prevent defining global constants using macros.","title":"Objects"},{"location":"manual/basics/coding_convention/#namespace","text":"All namespaces are named using the Pascal case. namespace Luna { namespace RHI { } } All Luna SDK components are defined in Luna namespace, every Luna SDK module except Runtime should have its own namespace under Luna containing its own components.","title":"Namespace"},{"location":"manual/basics/coding_convention/#macros","text":"Macros can be declared using two forms. The first form is uppercase words separated by underscores, with LUNA_ prefix. These macros are usually used for conditional compiling and replacing some platform-dependent keywords. #define LUNA_DEBUG 1 #define LUNA_PROFILE 1 #define LUNA_RELEASE 1 #if defined(LUNA_COMPILER_MSVC) #define LUNA_DLL_EXPORT __declspec(dllexport) #else #define LUNA_DLL_EXPORT __attribute__ ((visibility(\"default\"))) #endif The second form is the underscore case with lu prefix. These macros are usually used to replace some code patterns to improve coding efficiency. #define luassert(_condition) //... #define luassert_msg(_condition, _message) //... #define lustruct(_name, _guid) //... #define luproperty(_struct, _type, _name) //... #define luenum(_type, _name, _guid) //... #define luoption(_enum, _item) //... #define lucatchret //... Macro parameters are allowed for both macro forms. Macro parameter names should be prefixed with one underscore character.","title":"Macros"},{"location":"manual/basics/coding_convention/#templates","text":"Template type parameters should be decorated with typename instead of class , and should be prefixed with one underscore character. template <typename _Ty> struct less { constexpr bool operator()(const _Ty& lhs, const _Ty& rhs) const { return lhs < rhs; } };","title":"Templates"},{"location":"manual/basics/initialization_and_shutdown/","text":"Initialization and Shutdown SDK Initialization #include <Runtime/Runtime.hpp> Call Luna::init to initialize Luna SDK. Most features provided by Luna SDK are only available after Luna SDK is initialized, so always initialize Luna SDK firstly on program startup. Luna::init returns one bool value, which indicates whether the initialization is succeeded. After the initialization is succeeded, following calls to Luna::init does nothing and returns true directly. Note that modules registered to Luna SDK will not be initialized by Luna::init , they should be initialized manually using functions like init_modules . See Modules for details. SDK shutdown #include <Runtime/Runtime.hpp> Call Luna::close to close Luna SDK. Most features provided by Luna SDK are not available after Luna SDK is closed. If Luna SDK is already closed, calling Luna::close does nothing and returns directly. Unlike SDK initialization, initialized modules will be closed by Luna::close in the reverse order of their initialization order, so they don't need to be closed manually. Release resources before closing SDK All dynamic memory allocated from memalloc , memrealloc and memnew must be freed before calling Luna::close . All boxed object created from new_object and object_alloc must be released before calling Luna::close . Calls to memfree , memdelete , object_release and other functions after Luna::close results in undefined behavior, and usually a program crash. This often happens when you declare global variables that hold dynamic allocated resources (such as Ref ) and memory blocks (such as UniquePtr , and containers like Vector , HashMap , etc.). Remember to clear such resources before calling Luna::close . For some containers, you should call clear then shrink_to_fit to eventually frees the internal memory buffer used by containers.","title":"Initialization and Shutdown"},{"location":"manual/basics/initialization_and_shutdown/#initialization-and-shutdown","text":"","title":"Initialization and Shutdown"},{"location":"manual/basics/initialization_and_shutdown/#sdk-initialization","text":"#include <Runtime/Runtime.hpp> Call Luna::init to initialize Luna SDK. Most features provided by Luna SDK are only available after Luna SDK is initialized, so always initialize Luna SDK firstly on program startup. Luna::init returns one bool value, which indicates whether the initialization is succeeded. After the initialization is succeeded, following calls to Luna::init does nothing and returns true directly. Note that modules registered to Luna SDK will not be initialized by Luna::init , they should be initialized manually using functions like init_modules . See Modules for details.","title":"SDK Initialization"},{"location":"manual/basics/initialization_and_shutdown/#sdk-shutdown","text":"#include <Runtime/Runtime.hpp> Call Luna::close to close Luna SDK. Most features provided by Luna SDK are not available after Luna SDK is closed. If Luna SDK is already closed, calling Luna::close does nothing and returns directly. Unlike SDK initialization, initialized modules will be closed by Luna::close in the reverse order of their initialization order, so they don't need to be closed manually.","title":"SDK shutdown"},{"location":"manual/basics/initialization_and_shutdown/#release-resources-before-closing-sdk","text":"All dynamic memory allocated from memalloc , memrealloc and memnew must be freed before calling Luna::close . All boxed object created from new_object and object_alloc must be released before calling Luna::close . Calls to memfree , memdelete , object_release and other functions after Luna::close results in undefined behavior, and usually a program crash. This often happens when you declare global variables that hold dynamic allocated resources (such as Ref ) and memory blocks (such as UniquePtr , and containers like Vector , HashMap , etc.). Remember to clear such resources before calling Luna::close . For some containers, you should call clear then shrink_to_fit to eventually frees the internal memory buffer used by containers.","title":"Release resources before closing SDK"},{"location":"manual/basics/memory_management/","text":"Memory Management Luna SDK defines its own memory management functions instead of using those provided by standard libraries. The user should use functions provided by Luna SDK to manage memory when programming with Luna SDK. Heap memory allocation and deallocation #include <Runtime/Memory.hpp> The following functions allocate memory blocks in heaps. Function Description C++ STD Equivalent memalloc(size, alignment) Allocates memory block. malloc(size) memfree(ptr, alignment) Frees memory block. free(ptr) memrealloc(ptr, size, alignment) Reallocates memory block. realloc(ptr, size) memsize(ptr, alignment) Gets the size of the allocated memory block. N/A You may notice that all heap memory allocation functions provided by Luna SDK takes an alignment parameter, which can be used to allocate memory blocks with special address alignment requirements. If you don't have such requirement, simply specify alignment as 0 and Luna SDK will use the default alignment requirement for allocating memory blocks, which is 8 on 32-bit platforms and 16 on 64-bit platforms. Memory leak detection Luna SDK comes with an memory leak detection layer that tracks all memory blocks allocated from memalloc or memrealloc . The memory leak detection layer is disabled by default, you may enable it on xmake menus, or passing --check_memory_leak=true when building the SDK. You can use LUNA_RUNTIME_CHECK_MEMORY_LEAK macro to determine whether the memory leak detection layer is enabled. If memory leak detection layer is enabled and unfreed memory blocks are detected when Luna SDK is closing, Luna SDK will print warning messages for each unfreed memory block, including the size and the memory address of the block. If these blocks were allocated using memnew , the type of the block will also be printed, so that the user can detect the problem quickly. Dynamic object creation and destruction #include <Runtime/Memory.hpp> The following functions creates and destroys dynamic objects. Function Description C++ STD Equivalent memnew<T>(args...) Creates a dynamic object. new T(args...) memdelete(ptr) Destroys a dynamic object. delete ptr Out of memory (OOM) Although memalloc and memnew returns nullptr to indicate a failed memory allocation, most functions in Luna SDK do not handle OOM and assumes that the memory allocation will never fail. We treat OOM as an unrecoverable error for the following reasons: Dynamic memory allocation is used in throughout Luna SDK. If we need to handle OOM correctly, the SDK code will become much complex and redundant. It is not worthwhile to pay such effort to handle one error that seldom happens in normal cases. OOM actually never happens on some operating systems, if such system fails to allocate memory, it will simply kill the current process or let the user kill another process to free up some memory. We consider OOM as an optimization problem, not a programming error, so it is improper to \"handle\" it. If your program suffers from OOM on the target platform, the best thing to do is reducing the memory size consumed by your program, rather than trying to recover from OOM. Memory manipulating functions Luna SDK comes with some useful functions that can be used to manipulate memory data easily. You can check the docs for each function for their usages. Functions defined in Runtime/Base.hpp _kb , _mb , _gb , _tb are integer literals that can be used to define byte sizes clearly. For example, you can use 100_mb to represent 100 * 1024 * 1024 , and they have the same meaning. memcpy , memcmp , memset , memmove are memory manipulating functions provided by the C/C++ standard library. They can be used in Luna SDK as well. memzero is used to fill one range of memory with value 0 , it is equivalent to calling memset with value 0 . memcpy_bitmap and memcpy_bitmap3d are used to copy binary data between two row-major 2D and 3D bitmaps. pixel_offset is used to fetch the address of one particular pixel in a row-major 2D or 3D bitmap. These functions can be useful when dealing with bitmap data. align_upper increases the input size or address number to the nearest number that is a multiple of the alignment number. bit_test , bit_set , bit_reset tests, sets and resets one specific bit on the given memory address. These functions can be useful when performing bitwise operations. Functions defined in Runtime/MemoryUtils.hpp addressof returns the real address of one object, even if the operator& of the object has been overloaded. default_construct , value_construct , copy_construct , move_construct and direct_construct performs object initialization on the object pointed by the specified iterator/pointer. destruct performs object destruction on the object pointed by the specified iterator/pointer. copy_assign and move_assign perform copy assignment and move assignment on two objects pointed by the specified iterators/pointers. default_construct_range , value_construct_range , copy_construct_range and move_construct_range performs object initialization on objects in the range specified by two iterators/pointers. destruct_range performs object destruction on objects in the range specified by two iterators/pointers. copy_assign_range , move_assign_range and move_assign_range_backward performs copy assignment and move assignment on objects in the range specified by two iterators/pointers. fill_construct_range and fill_assign_range calls the copy constructor and copy assignment operator on objects with the specified instance. copy_relocate_range , copy_relocate , move_relocate_range and move_relocate_range_backward relocates objects in the range specified by two iterators/pointers to another continuous range, preserving the order of objects. If the object is trivially relocatable, this function will perform memory copy and does not invoke any move constructor; if the object is not trivially relocatable, this call performs move construction on the new address, and destruction on the old address.","title":"Memory Management"},{"location":"manual/basics/memory_management/#memory-management","text":"Luna SDK defines its own memory management functions instead of using those provided by standard libraries. The user should use functions provided by Luna SDK to manage memory when programming with Luna SDK.","title":"Memory Management"},{"location":"manual/basics/memory_management/#heap-memory-allocation-and-deallocation","text":"#include <Runtime/Memory.hpp> The following functions allocate memory blocks in heaps. Function Description C++ STD Equivalent memalloc(size, alignment) Allocates memory block. malloc(size) memfree(ptr, alignment) Frees memory block. free(ptr) memrealloc(ptr, size, alignment) Reallocates memory block. realloc(ptr, size) memsize(ptr, alignment) Gets the size of the allocated memory block. N/A You may notice that all heap memory allocation functions provided by Luna SDK takes an alignment parameter, which can be used to allocate memory blocks with special address alignment requirements. If you don't have such requirement, simply specify alignment as 0 and Luna SDK will use the default alignment requirement for allocating memory blocks, which is 8 on 32-bit platforms and 16 on 64-bit platforms.","title":"Heap memory allocation and deallocation"},{"location":"manual/basics/memory_management/#memory-leak-detection","text":"Luna SDK comes with an memory leak detection layer that tracks all memory blocks allocated from memalloc or memrealloc . The memory leak detection layer is disabled by default, you may enable it on xmake menus, or passing --check_memory_leak=true when building the SDK. You can use LUNA_RUNTIME_CHECK_MEMORY_LEAK macro to determine whether the memory leak detection layer is enabled. If memory leak detection layer is enabled and unfreed memory blocks are detected when Luna SDK is closing, Luna SDK will print warning messages for each unfreed memory block, including the size and the memory address of the block. If these blocks were allocated using memnew , the type of the block will also be printed, so that the user can detect the problem quickly.","title":"Memory leak detection"},{"location":"manual/basics/memory_management/#dynamic-object-creation-and-destruction","text":"#include <Runtime/Memory.hpp> The following functions creates and destroys dynamic objects. Function Description C++ STD Equivalent memnew<T>(args...) Creates a dynamic object. new T(args...) memdelete(ptr) Destroys a dynamic object. delete ptr","title":"Dynamic object creation and destruction"},{"location":"manual/basics/memory_management/#out-of-memory-oom","text":"Although memalloc and memnew returns nullptr to indicate a failed memory allocation, most functions in Luna SDK do not handle OOM and assumes that the memory allocation will never fail. We treat OOM as an unrecoverable error for the following reasons: Dynamic memory allocation is used in throughout Luna SDK. If we need to handle OOM correctly, the SDK code will become much complex and redundant. It is not worthwhile to pay such effort to handle one error that seldom happens in normal cases. OOM actually never happens on some operating systems, if such system fails to allocate memory, it will simply kill the current process or let the user kill another process to free up some memory. We consider OOM as an optimization problem, not a programming error, so it is improper to \"handle\" it. If your program suffers from OOM on the target platform, the best thing to do is reducing the memory size consumed by your program, rather than trying to recover from OOM.","title":"Out of memory (OOM)"},{"location":"manual/basics/memory_management/#memory-manipulating-functions","text":"Luna SDK comes with some useful functions that can be used to manipulate memory data easily. You can check the docs for each function for their usages.","title":"Memory manipulating functions"},{"location":"manual/basics/memory_management/#functions-defined-in-runtimebasehpp","text":"_kb , _mb , _gb , _tb are integer literals that can be used to define byte sizes clearly. For example, you can use 100_mb to represent 100 * 1024 * 1024 , and they have the same meaning. memcpy , memcmp , memset , memmove are memory manipulating functions provided by the C/C++ standard library. They can be used in Luna SDK as well. memzero is used to fill one range of memory with value 0 , it is equivalent to calling memset with value 0 . memcpy_bitmap and memcpy_bitmap3d are used to copy binary data between two row-major 2D and 3D bitmaps. pixel_offset is used to fetch the address of one particular pixel in a row-major 2D or 3D bitmap. These functions can be useful when dealing with bitmap data. align_upper increases the input size or address number to the nearest number that is a multiple of the alignment number. bit_test , bit_set , bit_reset tests, sets and resets one specific bit on the given memory address. These functions can be useful when performing bitwise operations.","title":"Functions defined in Runtime/Base.hpp"},{"location":"manual/basics/memory_management/#functions-defined-in-runtimememoryutilshpp","text":"addressof returns the real address of one object, even if the operator& of the object has been overloaded. default_construct , value_construct , copy_construct , move_construct and direct_construct performs object initialization on the object pointed by the specified iterator/pointer. destruct performs object destruction on the object pointed by the specified iterator/pointer. copy_assign and move_assign perform copy assignment and move assignment on two objects pointed by the specified iterators/pointers. default_construct_range , value_construct_range , copy_construct_range and move_construct_range performs object initialization on objects in the range specified by two iterators/pointers. destruct_range performs object destruction on objects in the range specified by two iterators/pointers. copy_assign_range , move_assign_range and move_assign_range_backward performs copy assignment and move assignment on objects in the range specified by two iterators/pointers. fill_construct_range and fill_assign_range calls the copy constructor and copy assignment operator on objects with the specified instance. copy_relocate_range , copy_relocate , move_relocate_range and move_relocate_range_backward relocates objects in the range specified by two iterators/pointers to another continuous range, preserving the order of objects. If the object is trivially relocatable, this function will perform memory copy and does not invoke any move constructor; if the object is not trivially relocatable, this call performs move construction on the new address, and destruction on the old address.","title":"Functions defined in Runtime/MemoryUtils.hpp"},{"location":"manual/basics/modules/","text":"Modules Luna SDK is a modular framework, every function of Luna SDK is provided by one or more modules. The fundamental functions of Luna SDK are provided by Runtime module, which will be initialized along with Luna SDK and is can be used anywhere. Other functions are provided by dedicated modules and should be added to Luna SDK explicitly when required. Module files Every Luna SDK module should have its own directory under ${ROOT_DIR}/Modules directory, with the module name as the directory name. Under the module root directory, every module must have one xmake.lua script defining the building rules of the module. The user can use the following code as the starting point for new modules: target(\"MyModule\") set_luna_sdk_module() add_headerfiles(\"*.hpp\", \"Source/**.hpp\") add_files(\"Source/**.cpp\") add_deps(\"Runtime\", \"MuDepModule1\", \"MyDepModule2\") target_end() set_luna_sdk_module() tells xmake to import all Luna SDK module global options and specifications to the current module, including one set_kind call to properly set the module target file kind. One module may be built into one static library ( .lib or .o ) or one shared library ( .dll or .so ) based on build_shared_lib xmake config of Luna SDK. add_headerfiles and add_files imports module header files ( .h , .hpp and .inl ) and module source files ( .c , .cpp ) to the module. add_deps adds dependency modules for the current module, so that they can be linked correctly. Every module should have one Source directory under the module root directory that contains all private files and directories only visible to the current module. All files and directories that are not in Source directory will be considered as module public files and should not contain module source files ( .c , .cpp files). Luna SDK sets ${ROOT_DIR}/Modules as the global include directory for all modules and programs, so you can simply include module interface files by #include <ModuleName/FileName.hpp> , like #include <RHI/RHI.hpp> . Module namespace Every module should declare all entities under its own namespace under Luna namespace. The namespace name for the module should be concise and is may not be equal to the name of the module. Do not declare using namespace under the module interface header files. namespace Luna { namespace MyModule { // Your declarations goes here... } } Module API declaration Module API functions and variables should have special linkage and codec specifications to be exported and linked correctly when compiled to shared or static libraries. Every module should use LUNA_XXX_API macro to decorate all APIs of the module, where XXX is the name of your module. LUNA_XXX_API should be defined like so in the module header files: #ifndef LUNA_XXX_API #define LUNA_XXX_API #endif // Your API. LUNA_XXX_API void do_something(); When you need to provide definitions for APIs on module source files, define LUNA_XXX_API before including header files like so: #include <Runtime/PlatformDefines.hpp> #define LUNA_XXX_API LUNA_EXPORT // Include your header files... This will overwrite LUNA_XXX_API with LUNA_EXPORT , which is a predefined platform-specific macro to append linkage and codec declarations for API functions and objects. Module registration #include <Runtime/Module.hpp> One module must be registered to Luna SDK before it can be initialized and used by your program or other modules. Modules are described by ModuleDesc structure, you can fill this structure and call add_module to add one module to Luna SDK. ModuleDesc desc; desc.name = \"MyModule\"; desc.dependencies = \"MuDepModule1;MyDepModule2\"; // `Runtime` is always included and should not be listed here. desc.init_func = my_module_init; // Can be `nullptr` if not needed. desc.close_func = my_module_close; // Can be `nullptr` if not needed. add_module(&desc); add_module is one of few functions that can be called before Luna SDK is initialized. StaticRegisterModule uses this behavior to register modules automatically by calling add_module in its constructor. We can simply declare it as a global object for our module to register our module automatically when the module library is loaded. StaticRegisterModule my_module(\"MyModule\", \"MuDepModule1;MyDepModule2\", my_module_init, my_module_close); Module initialization #include <Runtime/Module.hpp> Modules are not initialized along with Luna SDK and should be manually initialized after Luna SDK is initialized. This behavior enables the user to have a precisely control over module initialization time and can perform some extra operations before the module is initialized. Module system provides three methods to initialize modules: init_modules , init_module and init_module_dependencies . init_modules initialize all uninitialized modules registered to Luna SDK, by their dependency order. This is the simplest way to initialize all modules in one call, but the user does not have much control during the module initialization process. init_module initializes one specific module and all its recursively dependency modules of that module by their dependency order, while init_module_dependencies only initializes all recursively dependency modules of the specified module by their dependency order, but not the specified module. These two functions let the user pause the module initialization process to perform some extra tasks (like choosing the default graphic device), then continue to initialize other modules, which make the module initialization process more flexible. Module closing Modules are closed along with Luna SDK in the reverse order of their initialization order. There is no approach to close modules manually.","title":"Modules"},{"location":"manual/basics/modules/#modules","text":"Luna SDK is a modular framework, every function of Luna SDK is provided by one or more modules. The fundamental functions of Luna SDK are provided by Runtime module, which will be initialized along with Luna SDK and is can be used anywhere. Other functions are provided by dedicated modules and should be added to Luna SDK explicitly when required.","title":"Modules"},{"location":"manual/basics/modules/#module-files","text":"Every Luna SDK module should have its own directory under ${ROOT_DIR}/Modules directory, with the module name as the directory name. Under the module root directory, every module must have one xmake.lua script defining the building rules of the module. The user can use the following code as the starting point for new modules: target(\"MyModule\") set_luna_sdk_module() add_headerfiles(\"*.hpp\", \"Source/**.hpp\") add_files(\"Source/**.cpp\") add_deps(\"Runtime\", \"MuDepModule1\", \"MyDepModule2\") target_end() set_luna_sdk_module() tells xmake to import all Luna SDK module global options and specifications to the current module, including one set_kind call to properly set the module target file kind. One module may be built into one static library ( .lib or .o ) or one shared library ( .dll or .so ) based on build_shared_lib xmake config of Luna SDK. add_headerfiles and add_files imports module header files ( .h , .hpp and .inl ) and module source files ( .c , .cpp ) to the module. add_deps adds dependency modules for the current module, so that they can be linked correctly. Every module should have one Source directory under the module root directory that contains all private files and directories only visible to the current module. All files and directories that are not in Source directory will be considered as module public files and should not contain module source files ( .c , .cpp files). Luna SDK sets ${ROOT_DIR}/Modules as the global include directory for all modules and programs, so you can simply include module interface files by #include <ModuleName/FileName.hpp> , like #include <RHI/RHI.hpp> .","title":"Module files"},{"location":"manual/basics/modules/#module-namespace","text":"Every module should declare all entities under its own namespace under Luna namespace. The namespace name for the module should be concise and is may not be equal to the name of the module. Do not declare using namespace under the module interface header files. namespace Luna { namespace MyModule { // Your declarations goes here... } }","title":"Module namespace"},{"location":"manual/basics/modules/#module-api-declaration","text":"Module API functions and variables should have special linkage and codec specifications to be exported and linked correctly when compiled to shared or static libraries. Every module should use LUNA_XXX_API macro to decorate all APIs of the module, where XXX is the name of your module. LUNA_XXX_API should be defined like so in the module header files: #ifndef LUNA_XXX_API #define LUNA_XXX_API #endif // Your API. LUNA_XXX_API void do_something(); When you need to provide definitions for APIs on module source files, define LUNA_XXX_API before including header files like so: #include <Runtime/PlatformDefines.hpp> #define LUNA_XXX_API LUNA_EXPORT // Include your header files... This will overwrite LUNA_XXX_API with LUNA_EXPORT , which is a predefined platform-specific macro to append linkage and codec declarations for API functions and objects.","title":"Module API declaration"},{"location":"manual/basics/modules/#module-registration","text":"#include <Runtime/Module.hpp> One module must be registered to Luna SDK before it can be initialized and used by your program or other modules. Modules are described by ModuleDesc structure, you can fill this structure and call add_module to add one module to Luna SDK. ModuleDesc desc; desc.name = \"MyModule\"; desc.dependencies = \"MuDepModule1;MyDepModule2\"; // `Runtime` is always included and should not be listed here. desc.init_func = my_module_init; // Can be `nullptr` if not needed. desc.close_func = my_module_close; // Can be `nullptr` if not needed. add_module(&desc); add_module is one of few functions that can be called before Luna SDK is initialized. StaticRegisterModule uses this behavior to register modules automatically by calling add_module in its constructor. We can simply declare it as a global object for our module to register our module automatically when the module library is loaded. StaticRegisterModule my_module(\"MyModule\", \"MuDepModule1;MyDepModule2\", my_module_init, my_module_close);","title":"Module registration"},{"location":"manual/basics/modules/#module-initialization","text":"#include <Runtime/Module.hpp> Modules are not initialized along with Luna SDK and should be manually initialized after Luna SDK is initialized. This behavior enables the user to have a precisely control over module initialization time and can perform some extra operations before the module is initialized. Module system provides three methods to initialize modules: init_modules , init_module and init_module_dependencies . init_modules initialize all uninitialized modules registered to Luna SDK, by their dependency order. This is the simplest way to initialize all modules in one call, but the user does not have much control during the module initialization process. init_module initializes one specific module and all its recursively dependency modules of that module by their dependency order, while init_module_dependencies only initializes all recursively dependency modules of the specified module by their dependency order, but not the specified module. These two functions let the user pause the module initialization process to perform some extra tasks (like choosing the default graphic device), then continue to initialize other modules, which make the module initialization process more flexible.","title":"Module initialization"},{"location":"manual/basics/modules/#module-closing","text":"Modules are closed along with Luna SDK in the reverse order of their initialization order. There is no approach to close modules manually.","title":"Module closing"},{"location":"manual/basics/strings/","text":"Strings Strings are sequences of characters represented by c8 , c16 and c32 , terminated by a null terminator ( \\0 ). Luna SDK provides various string types and libraries, they will be discuessed in this section. String types #include <Runtime/String.hpp> // For String, String16 and String32. #include <Runtime/Name.hpp> // For Name. Luna SDK provides two kinds of string types: String and Name . The String type is a sequence of c8 characters ended with \\0 . We designed String as a replacement of std::string in Luna SDK, so most methods used for std::string should work find with our String type. Besides the String type, we also have String16 and String32 as replacements for std::u16string and std::u32string that holds character sequences of c16 and c32 types. The Name type represents one immutable c8 string that is usually used as an identifier. We implemented a global name registry in Luna SDK so that every unique name will have only one data copy in the registry, and all Name objects with the same string data refers to that copy, thus can be compared for equality quickly. The name string data is reference counted, and will be freed when the last Name object that refers to the data is destructed. Strings stored in Name cannot be changed, if the user assigns Name with another string, the Name object will refer to another string data entry, remaining the original string entry unchanged. Name and String can be converted to each other implicitly. There is no enforced encoding format for string types, but most text processing APIs in Luna SDK expects UTF-8 encoded strings for String and Name types. Unicode encoding library #include <Runtime/UTF8.hpp> Unicode is a text encoding standard that is widely used in modern computers, programs and websites. Luna SDK comes with a built-in Unicode library for processing strings encoded in commonly-used Unicode formats, including UTF-8, UTF-16 (LE and GE) and UTF-32. Luna SDK uses 32-bit character type ( c32 ) to represent one Unicode character, the value of the character object represents the codepoint of the character in Unicode character table. One Unicode character can be encoded to 1 c32 character in UTF-32, 1 to 2 c16 characters in UTF-16, and 1 to 6 c8 characters in UTF-8. By definition, one Unicode character represented by c32 differs from one Unicode character encoded using UTF-32 (the first bit of one UTF-32 character must be 0, so only 2^32 Unicode codepoints can be represented in UTF-32). But in practice, all existing Unicode characters can be converted to their UTF-32 representation without any modification, so we do not differ one Unicode character from one UTF-32 character in this manual. utf8_charspan and utf16_charspan take one Unicode character, and return the number of c8 or c16 characters required to represent that character in UTF-8 or UTF-16 encoding. utf8_charlen and utf16_charlen take the first c8 or c16 character of one UTF-8 or UTF-16 encoded Unicode character, and return the number of bytes used for that character. These functions can be used to measure the size of one UTF-32 character in UTF-8 and UTF-16 encoding. utf8_strlen and utf16_strlen calculate the number of Unicode characters contained by a UTF-8 or UTF-16 encoded string, utf8_index and utf16_index return the index of the first c8 or c16 character of the n th Unicode character in a UTF-8 or UTF-16 ebcided string. These functions can be used to calculate the length of Unicode-encoded strings. utf8_encode_char and utf16_encode_char encode one Unicode character into multiple c8 or c16 characters using UTF-8 or UTF-16 encoding, write the encoded characters to the user-provided buffer, and return the number of characters written. utf8_decode_char and utf16_decode_char , on the other side, read multiple c8 or c16 characters from the user-provided buffer, and returns the Unicode character represented by these characters. utf16_to_utf8 converts a UTF-8 encoded string to a UTF-16 encoded string, and utf8_to_utf16 converts a UTF-16 encoded string to a UTF-8 encoded string. Both functions write result strings in a user-provided buffer, utf16_to_utf8_len and utf8_to_utf16_len can be used to calculate the minimum size (measured in number of c8 or c16 characters, not including the null terminator) required for the buffer to hold the result string. Base64 encoding library #include <Runtime/Base64.hpp> Base64 is an encoding format that represents arbitrary binary data using 64 printable characters, plus one character ( = ) for paddings. It is useful to store binary data in a text-based file. Luna SDK comes with a built-in Base64 library for encoding and decoding binary data using Base64. base64_encode encodes the binary data in the user-provided source buffer to a Base64 encoded string, and writes the string to the user-provided destination buffer. To determine the size of the destination buffer required, call base64_get_encoded_size with the size of the row binary data. base64_decode decodes the Base64 string in the user-provided source buffer to original binary data, and writes the binary data to the user-provided destination buffer. To determine the size of the destination buffer required, call base64_get_decoded_size with the size of the Base64 string, excluding the null terminator.","title":"Strings"},{"location":"manual/basics/strings/#strings","text":"Strings are sequences of characters represented by c8 , c16 and c32 , terminated by a null terminator ( \\0 ). Luna SDK provides various string types and libraries, they will be discuessed in this section.","title":"Strings"},{"location":"manual/basics/strings/#string-types","text":"#include <Runtime/String.hpp> // For String, String16 and String32. #include <Runtime/Name.hpp> // For Name. Luna SDK provides two kinds of string types: String and Name . The String type is a sequence of c8 characters ended with \\0 . We designed String as a replacement of std::string in Luna SDK, so most methods used for std::string should work find with our String type. Besides the String type, we also have String16 and String32 as replacements for std::u16string and std::u32string that holds character sequences of c16 and c32 types. The Name type represents one immutable c8 string that is usually used as an identifier. We implemented a global name registry in Luna SDK so that every unique name will have only one data copy in the registry, and all Name objects with the same string data refers to that copy, thus can be compared for equality quickly. The name string data is reference counted, and will be freed when the last Name object that refers to the data is destructed. Strings stored in Name cannot be changed, if the user assigns Name with another string, the Name object will refer to another string data entry, remaining the original string entry unchanged. Name and String can be converted to each other implicitly. There is no enforced encoding format for string types, but most text processing APIs in Luna SDK expects UTF-8 encoded strings for String and Name types.","title":"String types"},{"location":"manual/basics/strings/#unicode-encoding-library","text":"#include <Runtime/UTF8.hpp> Unicode is a text encoding standard that is widely used in modern computers, programs and websites. Luna SDK comes with a built-in Unicode library for processing strings encoded in commonly-used Unicode formats, including UTF-8, UTF-16 (LE and GE) and UTF-32. Luna SDK uses 32-bit character type ( c32 ) to represent one Unicode character, the value of the character object represents the codepoint of the character in Unicode character table. One Unicode character can be encoded to 1 c32 character in UTF-32, 1 to 2 c16 characters in UTF-16, and 1 to 6 c8 characters in UTF-8. By definition, one Unicode character represented by c32 differs from one Unicode character encoded using UTF-32 (the first bit of one UTF-32 character must be 0, so only 2^32 Unicode codepoints can be represented in UTF-32). But in practice, all existing Unicode characters can be converted to their UTF-32 representation without any modification, so we do not differ one Unicode character from one UTF-32 character in this manual. utf8_charspan and utf16_charspan take one Unicode character, and return the number of c8 or c16 characters required to represent that character in UTF-8 or UTF-16 encoding. utf8_charlen and utf16_charlen take the first c8 or c16 character of one UTF-8 or UTF-16 encoded Unicode character, and return the number of bytes used for that character. These functions can be used to measure the size of one UTF-32 character in UTF-8 and UTF-16 encoding. utf8_strlen and utf16_strlen calculate the number of Unicode characters contained by a UTF-8 or UTF-16 encoded string, utf8_index and utf16_index return the index of the first c8 or c16 character of the n th Unicode character in a UTF-8 or UTF-16 ebcided string. These functions can be used to calculate the length of Unicode-encoded strings. utf8_encode_char and utf16_encode_char encode one Unicode character into multiple c8 or c16 characters using UTF-8 or UTF-16 encoding, write the encoded characters to the user-provided buffer, and return the number of characters written. utf8_decode_char and utf16_decode_char , on the other side, read multiple c8 or c16 characters from the user-provided buffer, and returns the Unicode character represented by these characters. utf16_to_utf8 converts a UTF-8 encoded string to a UTF-16 encoded string, and utf8_to_utf16 converts a UTF-16 encoded string to a UTF-8 encoded string. Both functions write result strings in a user-provided buffer, utf16_to_utf8_len and utf8_to_utf16_len can be used to calculate the minimum size (measured in number of c8 or c16 characters, not including the null terminator) required for the buffer to hold the result string.","title":"Unicode encoding library"},{"location":"manual/basics/strings/#base64-encoding-library","text":"#include <Runtime/Base64.hpp> Base64 is an encoding format that represents arbitrary binary data using 64 printable characters, plus one character ( = ) for paddings. It is useful to store binary data in a text-based file. Luna SDK comes with a built-in Base64 library for encoding and decoding binary data using Base64. base64_encode encodes the binary data in the user-provided source buffer to a Base64 encoded string, and writes the string to the user-provided destination buffer. To determine the size of the destination buffer required, call base64_get_encoded_size with the size of the row binary data. base64_decode decodes the Base64 string in the user-provided source buffer to original binary data, and writes the binary data to the user-provided destination buffer. To determine the size of the destination buffer required, call base64_get_decoded_size with the size of the Base64 string, excluding the null terminator.","title":"Base64 encoding library"},{"location":"manual/basics/type_reflection/","text":"Type reflection Type reflection is the ability of a program to introspect type name, size, layout and other information in the program. Such ability can be used to write code that can operate on different types. Luna SDK comes with a run-time type reflection system that tracks most types used in the framework, it can also be extended to accept user-defined new types, including enumeration types, structure types and generic structure types. Type object #include <Runtime/TypeInfo.hpp> typeinfo_t represents one type object that stores the type information for one type registered to type reflection system. You can get the type object of one specified type by calling typeof<T>() . If the specified type is not registered, the program may fail to compile or nullptr will be returned. Type name and GUID #include <Runtime/Reflection.hpp> Every registered type can be identified by name or by GUID, you can get one type object from its name by calling get_type_by_name , and from its GUID by calling get_type_by_guid . The name and GUID of one type object can be fetched by calling get_type_name and get_type_guid . Every type must have one unique GUID, but multiple types may have the same name. If multiple types have the same name, each of them should have one unique alias so that it can be differed from others. If the type is defined in namespaces, its namespace should be appended before the type name, separated by double colons ( :: ). Type size and alignment #include <Runtime/Reflection.hpp> Every registered type except generic structure type will have one specific size and alignment value, which can be fetched by get_type_size and get_type_alignment . Generic structure type is not a real type and will return 0 for both functions. Type class #include <Runtime/Reflection.hpp> There are different type classes in Luna SDK, including: Primitive type Structure type Enumeration type Generic structure type Generic structure instanced type Every registered type in Luna SDK belong to one type class. You can use is_primitive_type , is_struct_type , is_enum_type , is_generic_struct_type and is_generic_struct_instanced_type to check the class of one typeinfo_t object. Primitive type Primitive types are predefined simple types, including void , u8 , i8 , u16 , i16 , u32 , i32 , u64 , i64 , usize , isize , c8 , c16 , c32 , f32 , f64 and bool . void is a special type with size and alignment equal to 0 , and is mainly used as type parameters of generic types. Primitive types cannot be registered by users. Structure type Structure types are used to represent a set of data of different types. Structure types may have properties (member objects), they can also define special functions called meta functions to let Luna SDK handle these types correctly. If such meta function is not provided, Luna SDK will use the default meta function for the type. The following table lists all meta functions provided for one structure type T . Meta function Usage Default meta function Constructor Constructs one object of type T . Calls constructors for all properties of T . Destructor Destructs one object of type T . Calls destructors for all properties of T . Copy constructor Constructs one object of type T by coping data from another object of type T . Calls copy constructors for all properties of T . Move constructor Constructs one object of type T by moving data from another object of type T . Calls move constructors for all properties of T . Copy assignment operator Assigns data of one object of type T by coping data from another object of type T . Calls copy assignment operator for all properties of T . Move assignment operator Assigns data of one object of type T by moving data from another object of type T . Calls move assignment operator for all properties of T . Note that once the user-defined meta function is provided, the corresponding default meta function will not be called. Enumeration type An enumeration type defines a group of options. Every enumeration have one integral underlying type, and every option of the enumeration is mapped to one specific value of that underlying type. Different options in the same enumeration must have different mapped values. Luna SDK supports multiple enumeration type , which enables the user to select multiple options instead of only one as the value of the enumeration. In such case, every option will take one bit of the underlying integral type, and the enumeration value is stored by bitwise OR combination of selected options. Generic structure type and generic structure instanced type Generic structure type represents one structure type with generic type parameters, such as Vector<T> . The number of generic type parameters can be uncertain, like Tuple<T1, T2, ...> . Generic structure types cannot be used directly, they must be instantiated to a generic structure instanced type by calling get_generic_instanced_type . The generic instantiation process is happened at run time, every generic instanced type with one particular set of generic structure type and generic type parameters will be instantiated only once, and the instantiated type will be reused. One generic structure instanced type can be used just as one normal structure type. Registering structure type #include <Runtime/Reflection.hpp> There are two methods to register one structure type. The first method is simpler and can be used for most cases, the second method is non-intrusive can be used if the structure is defined in another module or third-party library and cannot be changed directly. The first method The first method is to insert one lustruct macro in your structure definition, specifying the name and GUID of the structure. struct SpotLight { lustruct(\"SpotLight\", \"{2BB45396-E0E3-433E-8794-49BEE8BD1BB5}\"); Float3 intensity = { 0.5f, 0.5f, 0.5f }; f32 intensity_multiplier = 1.0f; f32 attenuation_power = 1.0f; f32 spot_power = 64.0f; }; Then you can call register_struct_type<T> to register the type. The properties of the type can be specified quickly using luproperty macro: register_struct_type<SpotLight>({ luproperty(SpotLight, Float3, intensity), luproperty(SpotLight, f32, intensity_multiplier), luproperty(SpotLight, f32, attenuation_power), luproperty(SpotLight, f32, spot_power) }); The second method In the second method, the user should fill one StructureTypeDesc structure, then call register_struct_type to register the type. For example, the following code registers Name type into the system. StructureTypeDesc desc; desc.guid = Guid(\"{E5EEA2C6-2D51-4658-9B3F-C141DDE983D8}\"); desc.name = \"Name\"; desc.alias = \"\"; desc.size = sizeof(Name); desc.alignment = alignof(Name); desc.base_type = nullptr; desc.ctor = nullptr; desc.dtor = default_dtor<Name>; desc.copy_ctor = default_copy_ctor<Name>; desc.move_ctor = default_move_ctor<Name>; desc.copy_assign = default_copy_assign<Name>; desc.move_assign = default_move_assign<Name>; desc.trivially_relocatable = true; typeinfo_t type = register_struct_type(desc); After the type is registered, the user should also implement typeof_t<T> structure for the type like so: // In .hpp file: LUNA_MYMODULE_API typeinfo_t get_my_type(); template <> struct typeof_t<MyType> { typeinfo_t operator()() const { return get_my_type(); } }; // In .cpp file: typeinfo_t g_my_type; LUNA_XXX_API typeinfo_t get_my_type() { return g_my_type; } Registering enumeration type #include <Runtime/Reflection.hpp> The user can use register_enum_type function and luoption macro to register one enumeration type. For example, if we have the following type: enum class CameraType : u32 { perspective = 0, orthographic = 1, }; The registration code will be: register_enum_type<CameraType>({ luoption(CameraType, perspective), luoption(CameraType, orthographic) }); Since enumeration types cannot include static variables, the GUID of the enumeration type must be declared separately using luenum like so: luenum(CameraType, \"CameraType\", \"{920C8F7F-7CEC-4776-BF01-1F63A4C51D9F}\"); luenum must be defined directly in Luna namespace, not the sub-namespace of Luna namespace. Registering generic structure type #include <Runtime/Reflection.hpp> Generic structure type is not actually a real type, but a type generator for generic structure instance types. To register one generic structure type, the user should fill one GenericStructureTypeDesc structure, and call register_generic_struct_type to register the generic structure type. The most important property of GenericStructureTypeDesc is instantiate , which is a callback function that generates one generic structure instance type based on type arguments provided: GenericStructureInstantiateInfo instantiate(typeinfo_t generic_type, const typeinfo_t* generic_arguments, usize num_generic_arguments) This function should returns one GenericStructureInstantiateInfo structure, which is similar to StructureTypeDesc and describes one generic structure instanced type. The generic structure instanced type is then registered to the system can will be returned by get_generic_instanced_type . The instantiation function never fails, if the instantiation function cannot handle the input type arguments, it should call lupanic_msg to crash the program. The base generic structure type and all its instanced types will have the same name and GUID, but each of them will have a unique typeinfo_t handle. You can get the type arguments of one generic structure instanced type by calling count_struct_generic_arguments and get_struct_generic_argument . Implementing typeof_t<T> for generic structure types The user can implement typeof_t<T> using C++ partial template specification like so: LUNA_RUNTIME_API typeinfo_t vector_type(); // Returns the generic structure type. template <typename _Ty> struct typeof_t<Vector<_Ty>> { typeinfo_t operator()() const { return get_generic_instanced_type(vector_type(), { typeof<_Ty>() }); } // Returns the generic structure instanced type. };","title":"Type Reflection"},{"location":"manual/basics/type_reflection/#type-reflection","text":"Type reflection is the ability of a program to introspect type name, size, layout and other information in the program. Such ability can be used to write code that can operate on different types. Luna SDK comes with a run-time type reflection system that tracks most types used in the framework, it can also be extended to accept user-defined new types, including enumeration types, structure types and generic structure types.","title":"Type reflection"},{"location":"manual/basics/type_reflection/#type-object","text":"#include <Runtime/TypeInfo.hpp> typeinfo_t represents one type object that stores the type information for one type registered to type reflection system. You can get the type object of one specified type by calling typeof<T>() . If the specified type is not registered, the program may fail to compile or nullptr will be returned.","title":"Type object"},{"location":"manual/basics/type_reflection/#type-name-and-guid","text":"#include <Runtime/Reflection.hpp> Every registered type can be identified by name or by GUID, you can get one type object from its name by calling get_type_by_name , and from its GUID by calling get_type_by_guid . The name and GUID of one type object can be fetched by calling get_type_name and get_type_guid . Every type must have one unique GUID, but multiple types may have the same name. If multiple types have the same name, each of them should have one unique alias so that it can be differed from others. If the type is defined in namespaces, its namespace should be appended before the type name, separated by double colons ( :: ).","title":"Type name and GUID"},{"location":"manual/basics/type_reflection/#type-size-and-alignment","text":"#include <Runtime/Reflection.hpp> Every registered type except generic structure type will have one specific size and alignment value, which can be fetched by get_type_size and get_type_alignment . Generic structure type is not a real type and will return 0 for both functions.","title":"Type size and alignment"},{"location":"manual/basics/type_reflection/#type-class","text":"#include <Runtime/Reflection.hpp> There are different type classes in Luna SDK, including: Primitive type Structure type Enumeration type Generic structure type Generic structure instanced type Every registered type in Luna SDK belong to one type class. You can use is_primitive_type , is_struct_type , is_enum_type , is_generic_struct_type and is_generic_struct_instanced_type to check the class of one typeinfo_t object.","title":"Type class"},{"location":"manual/basics/type_reflection/#primitive-type","text":"Primitive types are predefined simple types, including void , u8 , i8 , u16 , i16 , u32 , i32 , u64 , i64 , usize , isize , c8 , c16 , c32 , f32 , f64 and bool . void is a special type with size and alignment equal to 0 , and is mainly used as type parameters of generic types. Primitive types cannot be registered by users.","title":"Primitive type"},{"location":"manual/basics/type_reflection/#structure-type","text":"Structure types are used to represent a set of data of different types. Structure types may have properties (member objects), they can also define special functions called meta functions to let Luna SDK handle these types correctly. If such meta function is not provided, Luna SDK will use the default meta function for the type. The following table lists all meta functions provided for one structure type T . Meta function Usage Default meta function Constructor Constructs one object of type T . Calls constructors for all properties of T . Destructor Destructs one object of type T . Calls destructors for all properties of T . Copy constructor Constructs one object of type T by coping data from another object of type T . Calls copy constructors for all properties of T . Move constructor Constructs one object of type T by moving data from another object of type T . Calls move constructors for all properties of T . Copy assignment operator Assigns data of one object of type T by coping data from another object of type T . Calls copy assignment operator for all properties of T . Move assignment operator Assigns data of one object of type T by moving data from another object of type T . Calls move assignment operator for all properties of T . Note that once the user-defined meta function is provided, the corresponding default meta function will not be called.","title":"Structure type"},{"location":"manual/basics/type_reflection/#enumeration-type","text":"An enumeration type defines a group of options. Every enumeration have one integral underlying type, and every option of the enumeration is mapped to one specific value of that underlying type. Different options in the same enumeration must have different mapped values. Luna SDK supports multiple enumeration type , which enables the user to select multiple options instead of only one as the value of the enumeration. In such case, every option will take one bit of the underlying integral type, and the enumeration value is stored by bitwise OR combination of selected options.","title":"Enumeration type"},{"location":"manual/basics/type_reflection/#generic-structure-type-and-generic-structure-instanced-type","text":"Generic structure type represents one structure type with generic type parameters, such as Vector<T> . The number of generic type parameters can be uncertain, like Tuple<T1, T2, ...> . Generic structure types cannot be used directly, they must be instantiated to a generic structure instanced type by calling get_generic_instanced_type . The generic instantiation process is happened at run time, every generic instanced type with one particular set of generic structure type and generic type parameters will be instantiated only once, and the instantiated type will be reused. One generic structure instanced type can be used just as one normal structure type.","title":"Generic structure type and generic structure instanced type"},{"location":"manual/basics/type_reflection/#registering-structure-type","text":"#include <Runtime/Reflection.hpp> There are two methods to register one structure type. The first method is simpler and can be used for most cases, the second method is non-intrusive can be used if the structure is defined in another module or third-party library and cannot be changed directly.","title":"Registering structure type"},{"location":"manual/basics/type_reflection/#the-first-method","text":"The first method is to insert one lustruct macro in your structure definition, specifying the name and GUID of the structure. struct SpotLight { lustruct(\"SpotLight\", \"{2BB45396-E0E3-433E-8794-49BEE8BD1BB5}\"); Float3 intensity = { 0.5f, 0.5f, 0.5f }; f32 intensity_multiplier = 1.0f; f32 attenuation_power = 1.0f; f32 spot_power = 64.0f; }; Then you can call register_struct_type<T> to register the type. The properties of the type can be specified quickly using luproperty macro: register_struct_type<SpotLight>({ luproperty(SpotLight, Float3, intensity), luproperty(SpotLight, f32, intensity_multiplier), luproperty(SpotLight, f32, attenuation_power), luproperty(SpotLight, f32, spot_power) });","title":"The first method"},{"location":"manual/basics/type_reflection/#the-second-method","text":"In the second method, the user should fill one StructureTypeDesc structure, then call register_struct_type to register the type. For example, the following code registers Name type into the system. StructureTypeDesc desc; desc.guid = Guid(\"{E5EEA2C6-2D51-4658-9B3F-C141DDE983D8}\"); desc.name = \"Name\"; desc.alias = \"\"; desc.size = sizeof(Name); desc.alignment = alignof(Name); desc.base_type = nullptr; desc.ctor = nullptr; desc.dtor = default_dtor<Name>; desc.copy_ctor = default_copy_ctor<Name>; desc.move_ctor = default_move_ctor<Name>; desc.copy_assign = default_copy_assign<Name>; desc.move_assign = default_move_assign<Name>; desc.trivially_relocatable = true; typeinfo_t type = register_struct_type(desc); After the type is registered, the user should also implement typeof_t<T> structure for the type like so: // In .hpp file: LUNA_MYMODULE_API typeinfo_t get_my_type(); template <> struct typeof_t<MyType> { typeinfo_t operator()() const { return get_my_type(); } }; // In .cpp file: typeinfo_t g_my_type; LUNA_XXX_API typeinfo_t get_my_type() { return g_my_type; }","title":"The second method"},{"location":"manual/basics/type_reflection/#registering-enumeration-type","text":"#include <Runtime/Reflection.hpp> The user can use register_enum_type function and luoption macro to register one enumeration type. For example, if we have the following type: enum class CameraType : u32 { perspective = 0, orthographic = 1, }; The registration code will be: register_enum_type<CameraType>({ luoption(CameraType, perspective), luoption(CameraType, orthographic) }); Since enumeration types cannot include static variables, the GUID of the enumeration type must be declared separately using luenum like so: luenum(CameraType, \"CameraType\", \"{920C8F7F-7CEC-4776-BF01-1F63A4C51D9F}\"); luenum must be defined directly in Luna namespace, not the sub-namespace of Luna namespace.","title":"Registering enumeration type"},{"location":"manual/basics/type_reflection/#registering-generic-structure-type","text":"#include <Runtime/Reflection.hpp> Generic structure type is not actually a real type, but a type generator for generic structure instance types. To register one generic structure type, the user should fill one GenericStructureTypeDesc structure, and call register_generic_struct_type to register the generic structure type. The most important property of GenericStructureTypeDesc is instantiate , which is a callback function that generates one generic structure instance type based on type arguments provided: GenericStructureInstantiateInfo instantiate(typeinfo_t generic_type, const typeinfo_t* generic_arguments, usize num_generic_arguments) This function should returns one GenericStructureInstantiateInfo structure, which is similar to StructureTypeDesc and describes one generic structure instanced type. The generic structure instanced type is then registered to the system can will be returned by get_generic_instanced_type . The instantiation function never fails, if the instantiation function cannot handle the input type arguments, it should call lupanic_msg to crash the program. The base generic structure type and all its instanced types will have the same name and GUID, but each of them will have a unique typeinfo_t handle. You can get the type arguments of one generic structure instanced type by calling count_struct_generic_arguments and get_struct_generic_argument .","title":"Registering generic structure type"},{"location":"manual/basics/type_reflection/#implementing-typeof_tt-for-generic-structure-types","text":"The user can implement typeof_t<T> using C++ partial template specification like so: LUNA_RUNTIME_API typeinfo_t vector_type(); // Returns the generic structure type. template <typename _Ty> struct typeof_t<Vector<_Ty>> { typeinfo_t operator()() const { return get_generic_instanced_type(vector_type(), { typeof<_Ty>() }); } // Returns the generic structure instanced type. };","title":"Implementing typeof_t&lt;T&gt; for generic structure types"},{"location":"manual/basics/variant/","text":"Variant #include <Runtime/Variant.hpp> Variant is a dynamic typed object that stores data in a schema-less (self-described) manner. Variant is used as a general way of representing data for purposes like serialization and deserialization . Variant type The type of one Variant is represented by Variant::Type enumeration and can be fetched by calling type method. Luna SDK supports the following variant types: Null Number String Boolean BLOB Pointer Array of variants Associated array of variants Null variant Variant can be null , which represents the absence of value for the variant object. Calling type of one null variant returns Variant::Type::null , and calling valid of one null variant returns false . Number variant Number variant contains one number of integer or floating-point type. The number type of one number variant is represented by Variant::NumberType enumeration and can be fetched by calling number_type method. If the variant object is not a number type, NumberType::not_number will be returned. The number value of the variant can be fetched by calling unum , inum and fnum methods, each of them returns the underlying number in specified format with implicit type conversion when needed. If the variant type is not Variant::Type::number , 0 or 0.0 will be returned. One variant can be set to number by assigning it with one integer or floating-point value or instance. String variant String variant contains one single string represented by a Name object. You can fetch the underlying string of one variant by calling str() method, which returns one empty string if the type of the variant is not Variant::Type::string . We also provide c_str method to fetch the string buffer quickly, which will return \"\" if the variant is not Variant::Type::string . One variant can be set to string by assigning it with one Name instance, one String instance, one string literal, or one zero-terminated c8* pointer instance. Boolean variant Boolean variant contains only two kinds of values: true and false . The Boolean value of one variant can be fetched by calling boolean method, which returns false if the variant is not Variant::Type::boolean . One variant can be set to Boolean by assigning it with one bool value or instance. BLOB Variant BLOB variant contains one single binary large object. The data, size and alignment of the data can be fetched by calling blob_data , blob_size and blob_alignment methods. Note that Variant does optimizations for small blob data, so the blob data is not necessary represented by Blob . You may detach the blob data from the variant by calling blob_detach , which returns the blob data as a Blob object, and the variant will contain one empty blob after this operation. One variant can be set to pointer by assigning it with one Blob value or instance. Pointer Variant Pointer variant contains one type-less user pointer. The pointer is stored as-is and can be fetched by calling pointer method, which returns nullptr if the variant is not Variant::Type::pointer . One variant can be set to pointer by assigning it with one pointer value or instance. Array of variants Array variant contains one array of Variant objects, which acts as sub-objects of the current object. Note that Variant does optimizations for small array, so the array data is not necessary represented by Vector<Variant> . Associated array of variants Associated array variant contains one set of Variant objects, which acts as sub-objects of the current object. Unlike array variants, objects in associated array variant are indexed by Name objects, and does not have a particular order. Note that Variant does optimizations for small array, so the array data is not necessary represented by HashMap<Name, Variant> . For both array variants and associated array variants, size method returns the number of sub-objects in the array, and empty method returns true if size() returns 0 . The user can use subscript syntaxes ( [] ) to fetch elements in array variants ( [N] ) and associated array variants ( [\"Name\"] ), if the specified element does not exist, one null variant will be returned. Using subscript syntaxes for variants with incorrect types always return null objects. Variant differential #include <Runtime/VariantDiff.hpp> Luna SDK comes with one variant differential library that computes and patches variant differences. diff_variant calculates the difference between before and after variant objects, and returns the difference as another variant object called diff object. patch_variant_diff applies diff object to before variant object to reproduce after object, and reverse_variant_diff removes the diff object from after object to reproduce before object. These functions are useful for implementing data versioning and undo/redo operations.","title":"Variant"},{"location":"manual/basics/variant/#variant","text":"#include <Runtime/Variant.hpp> Variant is a dynamic typed object that stores data in a schema-less (self-described) manner. Variant is used as a general way of representing data for purposes like serialization and deserialization .","title":"Variant"},{"location":"manual/basics/variant/#variant-type","text":"The type of one Variant is represented by Variant::Type enumeration and can be fetched by calling type method. Luna SDK supports the following variant types: Null Number String Boolean BLOB Pointer Array of variants Associated array of variants","title":"Variant type"},{"location":"manual/basics/variant/#null-variant","text":"Variant can be null , which represents the absence of value for the variant object. Calling type of one null variant returns Variant::Type::null , and calling valid of one null variant returns false .","title":"Null variant"},{"location":"manual/basics/variant/#number-variant","text":"Number variant contains one number of integer or floating-point type. The number type of one number variant is represented by Variant::NumberType enumeration and can be fetched by calling number_type method. If the variant object is not a number type, NumberType::not_number will be returned. The number value of the variant can be fetched by calling unum , inum and fnum methods, each of them returns the underlying number in specified format with implicit type conversion when needed. If the variant type is not Variant::Type::number , 0 or 0.0 will be returned. One variant can be set to number by assigning it with one integer or floating-point value or instance.","title":"Number variant"},{"location":"manual/basics/variant/#string-variant","text":"String variant contains one single string represented by a Name object. You can fetch the underlying string of one variant by calling str() method, which returns one empty string if the type of the variant is not Variant::Type::string . We also provide c_str method to fetch the string buffer quickly, which will return \"\" if the variant is not Variant::Type::string . One variant can be set to string by assigning it with one Name instance, one String instance, one string literal, or one zero-terminated c8* pointer instance.","title":"String variant"},{"location":"manual/basics/variant/#boolean-variant","text":"Boolean variant contains only two kinds of values: true and false . The Boolean value of one variant can be fetched by calling boolean method, which returns false if the variant is not Variant::Type::boolean . One variant can be set to Boolean by assigning it with one bool value or instance.","title":"Boolean variant"},{"location":"manual/basics/variant/#blob-variant","text":"BLOB variant contains one single binary large object. The data, size and alignment of the data can be fetched by calling blob_data , blob_size and blob_alignment methods. Note that Variant does optimizations for small blob data, so the blob data is not necessary represented by Blob . You may detach the blob data from the variant by calling blob_detach , which returns the blob data as a Blob object, and the variant will contain one empty blob after this operation. One variant can be set to pointer by assigning it with one Blob value or instance.","title":"BLOB Variant"},{"location":"manual/basics/variant/#pointer-variant","text":"Pointer variant contains one type-less user pointer. The pointer is stored as-is and can be fetched by calling pointer method, which returns nullptr if the variant is not Variant::Type::pointer . One variant can be set to pointer by assigning it with one pointer value or instance.","title":"Pointer Variant"},{"location":"manual/basics/variant/#array-of-variants","text":"Array variant contains one array of Variant objects, which acts as sub-objects of the current object. Note that Variant does optimizations for small array, so the array data is not necessary represented by Vector<Variant> .","title":"Array of variants"},{"location":"manual/basics/variant/#associated-array-of-variants","text":"Associated array variant contains one set of Variant objects, which acts as sub-objects of the current object. Unlike array variants, objects in associated array variant are indexed by Name objects, and does not have a particular order. Note that Variant does optimizations for small array, so the array data is not necessary represented by HashMap<Name, Variant> . For both array variants and associated array variants, size method returns the number of sub-objects in the array, and empty method returns true if size() returns 0 . The user can use subscript syntaxes ( [] ) to fetch elements in array variants ( [N] ) and associated array variants ( [\"Name\"] ), if the specified element does not exist, one null variant will be returned. Using subscript syntaxes for variants with incorrect types always return null objects.","title":"Associated array of variants"},{"location":"manual/basics/variant/#variant-differential","text":"#include <Runtime/VariantDiff.hpp> Luna SDK comes with one variant differential library that computes and patches variant differences. diff_variant calculates the difference between before and after variant objects, and returns the difference as another variant object called diff object. patch_variant_diff applies diff object to before variant object to reproduce after object, and reverse_variant_diff removes the diff object from after object to reproduce before object. These functions are useful for implementing data versioning and undo/redo operations.","title":"Variant differential"},{"location":"manual/introduction/","text":"Introduction Thanks for using Luna SDK. This user manual provides a comprehensive explanation of every aspect of Luna SDK, and is served for your reference. If you are completely new to Luna SDK, we suggest you to follow the step-by-step Getting Started tutorial for a quick boot. Then you should read the Basics chapter for a deeper understanding of the basic usage of Luna SDK. Other chapters in this manual does not have a particular dependency, you can read these chapters in any order, and in any time you want.","title":"Introduction"},{"location":"manual/introduction/#introduction","text":"Thanks for using Luna SDK. This user manual provides a comprehensive explanation of every aspect of Luna SDK, and is served for your reference. If you are completely new to Luna SDK, we suggest you to follow the step-by-step Getting Started tutorial for a quick boot. Then you should read the Basics chapter for a deeper understanding of the basic usage of Luna SDK. Other chapters in this manual does not have a particular dependency, you can read these chapters in any order, and in any time you want.","title":"Introduction"},{"location":"manual/introduction/getting_started/","text":"Getting Started Welcome to Luna SDK. In this article, we will guide you to Luna SDK by creating a simple program that draws one textured 3D cube on the screen. At the end of this article, you will have a basic understanding of using Luna SDK to create a simple graphic program, and can start to explore more advanced features provided by Luna SDK. Prerequisites In this article, we assume that you have the basic knowledge of C++ programming and graphics programming (like using D3D11, D3D12 or OpenGL). You should also correctly setup Luna SDK and developing environments using the instructions provided in README.md of the project. Creating the program The first thing to do is to create an binary target for our demo program, so that XMake build system can correctly build our program. To create a new program, create a new folder in the {LUNA_ROOT_DIR}/Programs directory, and name it DemoApp . In this folder, create a new Lua script file called xmake.lua , and fill its content with the following text: target(\"DemoApp\") set_luna_program() add_files(\"**.cpp\") add_deps(\"Runtime\", \"Window\", \"RHI\", \"ShaderCompiler\", \"Image\") target_end() target and target_end enclose a target scope , where all target definitions are specified. set_luna_program tells XMake that we are defining one Luna SDK program, this will let XMake set the target kind to \"binary\" and import all SDK options for the program. add_files(\"**.cpp\") tells XMake to add all CPP files in the current directory and all subdirectories to the this target. add_deps lists all libraries that this program links to, in our example, we need to link to the SDK runtime ( Runtime ), the window module ( Window ) , the Graphics API module ( RHI ), the shader compiler module ( ShaderCompiler ) and the image file module ( Image ). If you got unresolved external symbol errors when compiling, make sure you already link correct libraries. Then we need to create source CPP files for our program. Since out demo program is simple, we only create one \"main.cpp\" file to host all source codes. After this, the DemoApp directory should looks like this: DemoApp |- xmake.lua |- main.cpp The last thing is to add one line in the end of {LUNA_ROOT_DIR}/Programs/xmake.lua to tell XMake to add our program in the solution: includes(\"DemoApp\") Well done, now every is set up and we can start to program our first Luna SDK program! Program structure Next, fills main.cpp with the following initial content. As we go further, we will add more properties and methods to our DemoApp structure, while remaining the rest part unchanged. #include <Runtime/Runtime.hpp> #include <Runtime/Module.hpp> #include <Runtime/Debug.hpp> using namespace Luna; struct DemoApp { RV init(); RV update(); bool is_closed(); }; DemoApp* g_app = nullptr; RV DemoApp::init() { return ok; } RV DemoApp::update() { return ok; } bool DemoApp::is_closed() { return false; } RV run_app() { auto result = init_modules(); if(failed(result)) return result; g_app = memnew<DemoApp>(); result = g_app->init(); if(failed(result)) return result; while(!g_app->is_closed()) { result = g_app->update(); if(failed(result)) return result; } return ok; } int main() { bool initialized = Luna::init(); if(!initialized) return -1; RV result = run_app(); if(failed(result)) debug_printf(explain(result.errcode())); if(g_app) memdelete(g_app); Luna::close(); return 0; } The first three lines includes the header files that we need to include to compile the program, which are: * for Luna::init() and Luna::shutdown() . for Luna::init_modules() . for Luna::debug_printf() . You can include any SDK interface header files using similar syntax: #include <Module/File> . We set {LUNA_ROOT_DIR}/Engine as the global include directory, the user may check it for available header files. In this example, all header files are from the Runtime module, which is the core module of Luna SDK that provides fundamental SDK features. The next statement is using namespace Luna . In Luna SDK, all types, functions and variables are defined in Luna namespace, and every module will define its elements in nested namespace, such as Luna::RHI . So, we use this statement to prevent spelling the Luna:: namespace prefix in our following code. The program starts with the main function, just like any normal C/C++ program. In the main function, we firstly call Luna::init to initialize Luna SDK. This function should be called before any other Luna SDK function. Luna::init returns one Boolean value to indicate whether the SDK initialization is succeeded, if the return value is false , we then return -1 and exit the program to indicate one runtime error. If Luna::init returns true , then one Luna::close call is need before the program exit to let the SDK clean up all internal resources. We then wrap the real program logic in one run_app function. The return type of run_app is RV , which is a shortcut for R<void> , this is part of the error handling mechanism of Luna SDK. R<T> is a structure that encapsulates one return value with type T and one error code with type ErrCode , which is simply an alias of usize (or std::size_t ). If the function succeeds, the returned value will be one T -typed value and one error code 0 ; if the function fails, the returned value will be one non-zero error code, and the T -typed value will be uninitialized and inaccessible, you may call errcode() to fetch the error code from R<T> , and may call explain to get a brief description of the error. In our main function, we check whether our run_app function is failed by using failed helper function (there is also one succeeded helper function available), then we print the error description and exits the program if any error occurs. In our run_app function, the first thing to do is calling init_modules , which will initialize all linked SDK modules for our program. We deliberately separate module initialization from Luna::init so that the user get a chance to set module initialization parameters before initializing modules, and modules can also indicate initialization failure by returning error codes (error handling system is available after Luna::init ). Then, we allocate and initialize one new object of DemoApp type by calling memnew function. The following table shows memory allocation functions used in Luna SDK: Luna SDK functions C++ functions/keywords memalloc(size, alignment) malloc(size) memfree(ptr, alignment) free(ptr) memrealloc(ptr, size, alignment) realloc(ptr, size) memsize(size, alignment) N/A memnew<T>(args...) new T (args...) memdelete(ptr) delete ptr The user should uses allocation functions provided by Luna SDK instead of those provided by C++ std. DemoApp will contain all states and logics for our demo program. The created DempApp instance then will be assigned to a global variable g_app , and will be deleted by memdelete when the program exits. DemoApp has three functions: init , update and is_closed . The init function initializes the program, and reports errors if the initialization is failed; the update function updates the program state and renders the image at every frame; the is_exiting function checks whether the program is exiting. We will implement these three methods in the following sections. The rest part of our run_app function simply checks whether the program is exiting by calling is_exiting , and updates the program when it is not exiting. After filling this content, execute xmake build DemoApp on terminal or click build button on your IDE, you should successfully build the DemoApp program. Window creation and event handling Now that we have one basic program structure, we need to create a system window so that we can render images to it. We also need to implement window event handling so that the program can exit when the user clicks the close button of the window. Window creation is fairly simple, we firstly need to introduce one new header: #include <Window/Window.hpp> then we add one new property to our DemoApp structure: struct DemoApp { Ref<Window::IWindow> window; RV init(); RV update(); bool is_exiting(); RV resize(u32 width, u32 height); }; The window object is provided by Window::IWindow* interface pointer in Luna SDK, which points to a boxed object which manages its lifetime using reference counting . IWindow interface may have different implementations on different platforms, by they all provide the same functionality required by this interface. Ref<T> is a smart pointer for boxed objects, it will manage the reference counter of the pointing object automatically when being constructed and destructed, so the user does not need to call object_retain and object_release manually. You may compare Ref<T> to ComPtr used in Microsoft's Component-Object Model (COM), or the automatic reference counting in Apple's Objective-C and Swift. The default constructor of Ref<T> initializes the pointer to nullptr , so we need to assign it with a valid object. Then we need to create our window in DemoApp::init : RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); } lucatch { return lures; } return ok; } Besides the new_window function that creates the window, there are four new keywords in our code: lutry , lucatch , luset and lures . These four keywords are macros that enables us to write error handling using a simpler try-catch style, rather than fetching and checking error codes once and once again for every function call that may fail. lutry and lucatch must be used in pairs, next to each other. In the lutry block, the user may define multiple lulet , luset or luexp statements, lulet statement creates a new local variable to hold the return value of the function, and jumps to lucatch if the function fails; luset assigns the return value to one existing variable, and jumps to lucatch if the function fails; luexp is used if the function does not return any value, it simply checks whether the function succeeds, and jumps to lucatch if not. The user may also call luthrow manually in lutry block to jump to lucatch directly. In the lucatch block, lures is provided as the error code that causes the failure. You may use one switch statement on the lures to handle specific errors, or you can propagate the error directly to parent function by return lures . Since error propagating is so commonly used, we create another macro lucatchret to replace lucatch { return lures; } , so the code above can be written as: RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); } lucatchret; return ok; } Since we use goto statement to implement lutry and lucatch , it you needs multiple lutry-lucatch pairs in one function, you should use a numbered version for every pair (like lutry2 , lucatch2 , luset 2, lures2 , etc.). In most cases, only one lutry-lucatch pair is sufficient. Now let's get back to Window::new_window function that does the actual work. The function signature of this function is: R<Ref<IWindow>> new_window(const c8* title, i32 x, i32 y, i32 width, i32 height, monitor_t monitor = nullptr, WindowCreationFlag flags = WindowCreationFlag::none) Most parameters are self-explained, monitor is one handle to one system monitor, if you need to create a full-screen window, you need to specify the monitor to create window for, otherwise just leave it nullptr . flags are a combination of WindowCreationFlag enumeration class that lists flags for window creation process. If WindowCreationFlag::position_center is set, then x and y will be ignored and the window will be positioned on the center of the primary monitor; if Window::WindowCreationFlag::default_size is set, then width and height will be ignored and the window size will be set to a proper value based on the primary monitor's resolution. After the window is created, we need to register window event callbacks so that we can handle window events properly. In this example, the events we need to handle is the close event (triggered when the close button of the window is pressed) and the framebuffer resize event (triggered when the window framebuffer size is changed). This can be done by the following statements: window->get_close_event() += [](Window::IWindow* window) { window->close(); }; window->get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) { lupanic_if_failed(g_app->resize(width, height)); }; get_close_event and get_framebuffer_resize_event are methods of IWindow that gets the close event and the framebuffer resize event object of the window. The event object is a collection of callback functions that once triggered, calls all the callback functions. We then register one callback function to the close event that closes the window immediately, and one callback function to the framebuffer resize event that calls the resize method of our DempApp . The resize method is currently empty, we will fill the content of this method when we create render textures later: RV DemoApp::resize(u32 width, u32 height) { return ok; } Window events are not polled automatically, we need to tell the window system to poll events at every frame by calling Window::poll_events in update function: RV DemoApp::update() { Window::poll_events(); return ok; } This call polls events for all existing windows, so we don't need to provide specific window here. After we correctly handle the close event, we can complete the is_closed method of DemoApp : bool DemoApp::is_exiting() { return window->is_closed(); } So far, the complete code for main.cpp is: #include <Runtime/Runtime.hpp> #include <Runtime/Module.hpp> #include <Runtime/Debug.hpp> #include <Window/Window.hpp> using namespace Luna; struct DemoApp { Ref<Window::IWindow> window; RV init(); RV update(); bool is_exiting(); RV resize(u32 width, u32 height); }; DemoApp* g_app = nullptr; RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); window->get_close_event() += [](Window::IWindow* window) { window->close(); }; window->get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) { lupanic_if_failed(g_app->resize(width, height)); }; } lucatchret; return ok; } RV DemoApp::update() { Window::poll_events(); return ok; } bool DemoApp::is_exiting() { return window->is_closed(); } RV DemoApp::resize(u32 width, u32 height) { return ok; } RV run_app() { auto result = init_modules(); if(failed(result)) return result; g_app = memnew<DemoApp>(); result = g_app->init(); if(failed(result)) return result; while(!g_app->is_exiting()) { result = g_app->update(); if(failed(result)) return result; } return ok; } int main() { bool initialized = Luna::init(); if(!initialized) return -1; RV result = run_app(); if(failed(result)) debug_printf(explain(result.errcode())); if(g_app) memdelete(g_app); Luna::close(); return 0; } Build and run DemoApp , and you will see a blank window appears, and the program exits when you click the close button of the window. Fetching graphic device After the window is created, we can start drawing our box. In Luna SDK, all graphic resources are related to one specific graphic device represented by RHI::IDevice , which is the virtual representation of the physical graphic device on the platform, so we need to add one property to DemoApp to hold this device: Ref<RHI::IDevice> dev; When RHI module initializes, it automatically chooses the most suitable physical device and creates one device for you, which can be fetched by RHI::get_main_device() . You may also create additional devices for special use, but in our DemoApp , we will stick to the default one by adding the following line in the lutry scope of DemoApp::init : dev = RHI::get_main_device(); We can also import all RHI types and functions by using namespace RHI; so that we don't need to spell them all over the init function: using namespace RHI; The code of DemoApp::init should look similar to: RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); window->get_close_event() += [](Window::IWindow* window) { window->close(); }; window->get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) { lupanic_if_failed(g_app->resize(width, height)); }; dev = RHI::get_main_device(); using namespace RHI; // New resource creation code goes here... } lucatchret; return ok; } Unless explicitly specified, all codes we need to add to DemoApp::init in the following sections are added to the end of lutry scope, not in the end of the function scope directly. Creating command queue and command buffer Luna SDK employs deferred execution model , where render and compute calls are recorded as commands in command buffers , then submitted to GPU explicitly by submitting command buffers to command queues . The command buffer object manages memory allocated to store commands, it also tracks the execution state for commands in the buffer when the buffer is submitted for execution. The command queue object is a FIFO message buffer between CPU and GPU. CPU can push command buffers into the queue, and GPU will pop command buffers from the queue and execute commands in the buffer. Command buffers in the queue are guaranteed to execute one after another, the next command buffer will not being executed until the last command buffer is finished. We need to add two new properties to DemoApp to hold the command queue and command buffer: Ref<RHI::ICommandQueue> queue; Ref<RHI::ICommandBuffer> cmdbuf; Then we can create the objects by adding the following codes to DemoApp::init : luset(queue, dev->new_command_queue(CommandQueueType::graphic)); luset(cmdbuf, queue->new_command_buffer()); When creating command queues, we must specify the type of the queue. There are three different queue types: graphic , compute and copy . The copy queue only accepts copy commands, and is used for transferring data between different resources; the compute queue accepts copy and compute tasks, while the graphic queue accepts graphic, compute and copy commands. In our case, we need to create one graphic queue. Note that command buffers are created from command queues, not from the graphic device directly. Once the command buffer is created, it is bound to the queue who created the buffer, and the binding can not be changed. Creating swap chain The swap chain object contains resources that are used to present render results to our window. We need to add one new property to DemoApp to hold the command queue and command buffer: Ref<RHI::ISwapChain> swap_chain; In Luna SDK, the swap chain presentation is also a command that should be submitted using graphic command queues, so we need to specify the command queue we need to use when creating swap chains like so: luset(swap_chain, new_swap_chain(queue, window, SwapChainDesc(0, 0, Format::rgba8_unorm, 2))); The swap chain is described by one SwapChainDesc structure: struct SwapChainDesc { u32 width; u32 height; Format pixel_format; u32 buffer_count; }; When used for creating swap chains, you may pass 0 for width and height property, which indicates the system to use the window framebuffer size as the size of the swap chain. The swap chain needs to be resized when the window framebuffer size is changed. This can be done by filling DemoApp::resize method with the following codes: RV DemoApp::resize(u32 width, u32 height) { lutry { using namespace RHI; auto dev = get_main_device(); luexp(swap_chain->resize_buffers(2, width, height, Format::rgba8_unorm)); } lucatchret; return ok; } ISwapChain::resize_buffers will recreate the swap chain buffer according to the new window framebuffer size. Creating descriptor set layout and descriptor set The descriptor set object stores descriptors that bind resources to graphic or compute pipeline. Descriptors have the following types: Constant buffer view, which binds constant global data to shaders. Shader resource view, which binds read-only textures and structured buffers to shaders. Unordered access view, which binds writable resources to compute shaders. Sampler, which stores sampling settings and exposes those settings for shaders. Every pipeline may bind multiple descriptor sets, every descriptor set may contain all four kinds of descriptors listed above. The descriptor set layout object stores the layout of one descriptor set object, including the number of descriptors in the descriptor set and the property of each descriptor. In order to create one descriptor set layout object, we need to fill one DescriptorSetLayoutDesc structure. Here is the definition of DescriptorSetLayoutDesc structure: struct DescriptorSetLayoutDesc { Vector<DescriptorSetLayoutBinding> bindings; DescriptorSetLayoutFlag flags = DescriptorSetLayoutFlag::none; }; The descriptor set layout consists of multiple bindings specified by DescriptorSetLayoutBinding , each binding describes one range of the descriptor set: struct DescriptorSetLayoutBinding { DescriptorType type; u32 binding_slot; u32 num_descs; ShaderVisibility shader_visibility; }; the type property describes the type of this binding. All descriptors in the same binding must be the same type: enum class DescriptorType : u32 { srv, uav, cbv, sampler }; binding_slot and num_descs describes the binding slot range of this binding, starting from 0 . All slots in [binding_slot, binding_slot + num_descs) will be occupied by this binding and cannot be used by other bindings. If num_descs is greater than 1 , then this binding will be interpreted as one descriptor array in the shader. shader_visibility specifies which shader may access descriptors in this binding, you may restrict the visibility of one binding to one specific shader to potentially improve performance. We need to add two new properties to DemoApp to hold the descriptor set layout object and the descriptor set object: Ref<RHI::IDescriptorSetLayout> dlayout; Ref<RHI::IDescriptorSet> desc_set; We need 1 descriptor set with 1 constant buffer view, 1 shader resource view and 1 sampler. So we can create our descriptor set layout object in DemoApp::init like so: luset(dlayout, dev->new_descriptor_set_layout(DescriptorSetLayoutDesc({ {DescriptorType::cbv, 0, 1, ShaderVisibility::vertex}, {DescriptorType::srv, 1, 1, ShaderVisibility::pixel}, {DescriptorType::sampler, 2, 1, ShaderVisibility::pixel} }))); Then we can create one descriptor set using the descriptor set layout object: luset(desc_set, dev->new_descriptor_set(DescriptorSetDesc(dlayout))); We will fill descriptors in the set by calling set_cbv , set_srv and set_sampler later. Compiling shaders The next thing to do is compiling shaders for the pipeline state object. Luna SDK uses HLSL as the source shader language, and uses ShaderCompiler module to compile HLSL to DXBC, DXIL, SPIR-V and other target shading languages. To compile shader, we need to include corresponding header files: #include <ShaderCompiler/ShaderCompiler.hpp> #include <RHI/ShaderCompileHelper.hpp> ShaderCompileHelper.hpp includes RHI::get_current_platform_shader_target_format() function, which tell the shader compiler the native target target shader format for the current graphic API. Since our shader is rather simple, we declare our shader source code directly in the C++ source file, in DemoApp::init function: const char vs_shader_code[] = R\"( cbuffer vertexBuffer : register(b0) { float4x4 world_to_proj; }; struct VS_INPUT { float3 position : POSITION; float2 texcoord : TEXCOORD; }; struct PS_INPUT { float4 position : SV_POSITION; float2 texcoord : TEXCOORD; }; PS_INPUT main(VS_INPUT input) { PS_INPUT output; output.position = mul(world_to_proj, float4(input.position, 1.0f)); output.texcoord = input.texcoord; return output; })\"; const char ps_shader_code[] = R\"( Texture2D tex : register(t1); SamplerState tex_sampler : register(s2); struct PS_INPUT { float4 position : SV_POSITION; float2 texcoord : TEXCOORD; }; float4 main(PS_INPUT input) : SV_Target { return float4(tex.Sample(tex_sampler, input.texcoord)); })\"; here we use C++ raw string syntax R\"()\" to declare multiline string without appending \\ for every string line. Note the register number specified in shader must match the binding slot specified in descriptor set layout we just created. Since we use the same slot numbering system for all descriptor types, the register number for b , t , u and s should not overlap. Then we can compile shaders using ShaderCompiler::ICompiler object: auto compiler = ShaderCompiler::new_compiler(); compiler->set_source({ vs_shader_code, strlen(vs_shader_code) }); compiler->set_source_name(\"DemoAppVS\"); compiler->set_entry_point(\"main\"); compiler->set_target_format(RHI::get_current_platform_shader_target_format()); compiler->set_shader_type(ShaderCompiler::ShaderType::vertex); compiler->set_shader_model(5, 0); compiler->set_optimization_level(ShaderCompiler::OptimizationLevel::full); luexp(compiler->compile()); auto vs_data = compiler->get_output(); Blob vs(vs_data.data(), vs_data.size()); compiler->reset(); compiler->set_source({ ps_shader_code, strlen(ps_shader_code) }); compiler->set_source_name(\"DemoAppPS\"); compiler->set_entry_point(\"main\"); compiler->set_target_format(RHI::get_current_platform_shader_target_format()); compiler->set_shader_type(ShaderCompiler::ShaderType::pixel); compiler->set_shader_model(5, 0); compiler->set_optimization_level(ShaderCompiler::OptimizationLevel::full); luexp(compiler->compile()); auto ps_data = compiler->get_output(); Blob ps(ps_data.data(), ps_data.size()); The shader compilation process is fairly simple, we just set source code, compilation settings, then triggers the compilation. The compilation result will be given by get_output , we use one Blob object , a container for binary data, to hold the compilation result. The compiled shader data will be used when creating pipeline state object later. Creating shader input layout and pipeline state The graphic and compute pipeline state is described by two objects: shader input layout object and pipeline state object. Shader input layout object stores the shader binding layout information for all shader stages, while pipeline state object stores pipeline settings for all graphic stages. Shader input layout is described by the ShaderInputLayoutDesc structure, which is set by specifying layouts of descriptor sets that will be bound to this pipeline and flags that specifies shaders that are allowed to access shader inputs. struct ShaderInputLayoutDesc { Vector<IDescriptorSetLayout*> descriptor_set_layouts; ShaderInputLayoutFlag flags; }; We need to add one new property to DemoApp to hold the shader input layout object: Ref<RHI::IShaderInputLayout> slayout; Then we can create shader input layout object using the following code: luset(slayout, dev->new_shader_input_layout(ShaderInputLayoutDesc({dlayout}, ShaderInputLayoutFlag::allow_input_assembler_input_layout | ShaderInputLayoutFlag::deny_hull_shader_access | ShaderInputLayoutFlag::deny_domain_shader_access | ShaderInputLayoutFlag::deny_geometry_shader_access))); The pipeline object is described by the GraphicPipelineStateDesc structure or the ComputePipelineStateDesc structure. Since we are creating one graphic pipeline, we need to fill the GraphicPipelineStateDesc structure, which is a complex structure that contains all pipeline settings for one graphic pipeline: struct GraphicPipelineStateDesc { InputLayoutDesc input_layout; IShaderInputLayout* shader_input_layout = nullptr; Span<const byte_t> vs; Span<const byte_t> ps; Span<const byte_t> ds; Span<const byte_t> hs; Span<const byte_t> gs; StreamOutputDesc stream_output; BlendDesc blend_state; RasterizerDesc rasterizer_state; DepthStencilDesc depth_stencil_state; IndexBufferStripCutValue ib_strip_cut_value = IndexBufferStripCutValue::disabled; PrimitiveTopologyType primitive_topology_type = PrimitiveTopologyType::triangle; u32 num_render_targets = 0; Format rtv_formats[8] = { Format::unknown }; Format dsv_format = Format::unknown; u32 sample_count = 1; u32 sample_mask = 0xFFFFFFFF; u32 sample_quality = 0; }; Most graphic settings are similar to those in D3D11, D3D12, OpenGL or Vulkan, we will not explain these settings, but only gives the code that correctly sets every setting of the pipeline. You can see docs for RHI module for detailed explanations of these settings. We need to add one new property to DemoApp to hold the pipeline state object: Ref<RHI::IPipelineState> pso; Then we can create pipeline state object using the following code: GraphicPipelineStateDesc ps_desc; ps_desc.primitive_topology_type = PrimitiveTopologyType::triangle; ps_desc.sample_mask = U32_MAX; ps_desc.sample_quality = 0; ps_desc.blend_state = BlendDesc(false, false, { RenderTargetBlendDesc(false, false, BlendFactor::src_alpha, BlendFactor::inv_src_alpha, BlendOp::add, BlendFactor::inv_src_alpha, BlendFactor::zero, BlendOp::add, LogicOp::noop, ColorWriteMask::all) }); ps_desc.rasterizer_state = RasterizerDesc(FillMode::solid, CullMode::back, 0, 0.0f, 0.0f, 0, false, true, false, false, false); ps_desc.depth_stencil_state = DepthStencilDesc(true, true, ComparisonFunc::less_equal, false, 0x00, 0x00, DepthStencilOpDesc(), DepthStencilOpDesc()); ps_desc.ib_strip_cut_value = IndexBufferStripCutValue::disabled; ps_desc.input_layout = InputLayoutDesc({ {\"POSITION\", 0, Format::rgb32_float}, {\"TEXCOORD\", 0, Format::rg32_float}, }); ps_desc.vs = vs.cspan(); ps_desc.ps = ps.cspan(); ps_desc.shader_input_layout = slayout; ps_desc.num_render_targets = 1; ps_desc.rtv_formats[0] = Format::rgba8_unorm; ps_desc.dsv_format = Format::d32_float; luset(pso, dev->new_graphic_pipeline_state(ps_desc)); Creating render and depth textures The next step is to create the render texture and depth texture that is used as render target and depth stencil target. We also need to create render target view object and depth stencil view object for our render texture and depth texture. All graphic resources in Luna SDK, including buffers and textures, are described by ResourceDesc structure, and are represented by IResource interface. Here is the definition of the ResourceDesc structure: struct ResourceDesc { ResourceType type; ResourceHeapType heap_type; Format pixel_format; ResourceUsageFlag usages; u64 width_or_buffer_size; u32 height; u32 depth_or_array_size; u32 mip_levels; u32 sample_count; u32 sample_quality; ResourceFlag flags; }; type specifies the type of the resource, like buffer , texture_2d , etc. heap_type specifies which memory heap to create the resource in, possible options include: local - The resource can only be accessed by GPU, CPU access is disabled. This heap is suitable for GPU generated resources like temporary texture between render passes. shared and shared_upload - The resource can be accessed by both GPU and CPU, but is optimized for maximum GPU bandwidth, CPU access is slow and limited. shared_upload only allows CPU-write, while shared allows both CPU read and write. This heap is suitable for CPU-write-once textures like static textures read from file. upload - The resource can be written by CPU and read by GPU. This heap is suitable for resources that should be updated by CPU frequently. Textures cannot be created in this heap. readback - The resource can be written by GPU and read by CPU. This heap is suitable for transferring data from GPU to CPU frequently. Textures cannot be created in this heap. pixel_format specifies the pixel format of the resource if the resource is a texture, otherwise is ignored and will be set to unknown . usages specifies all possible roles of the resource when being bound to a pipeline. width_or_buffer_size , height and depth_or_array_size specifies the size of the resource, if the resource is a buffer, only width_or_buffer_size is used, and specifies the size of the buffer in bytes, otherwise, based on the type of the resource, those three properties specifies the width, height, depth (for 3D textures) or array size (for 1D and 2D textures) of the resource. mip_levels specifies the number of mips that should be allocated for the resource, if this is 0 , the system allocates full mipmap chain for the resource. sample_count and sample_quality specifies the sampling configuration for MSAA textures. flags specifies additional flags for the texture, like whether this texture can be simultaneously accessed by multiple command queues. To simplify the resource specification, we can use static methods provided by ResourceDesc to quickly construct ResourceDesc structure: ResourceDesc ResourceDesc::buffer(ResourceHeapType heap_type, ResourceUsageFlag usages, u64 size, ResourceFlag flags = ResourceFlag::none); ResourceDesc ResourceDesc::tex1d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u64 width, u32 array_size = 1, u32 mip_levels = 0, ResourceFlag flags = ResourceFlag::none); ResourceDesc ResourceDesc::tex2d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u32 width, u32 height, u32 array_size = 1, u32 mip_levels = 0, u32 sample_count = 1, u32 sample_quality = 0, ResourceFlag flags = ResourceFlag::none); ResourceDesc ResourceDesc::tex3d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u32 width, u32 height, u32 depth, u32 mip_levels = 0, ResourceFlag flags = ResourceFlag::none); Back to our DemoApp , we need to add four new properties to DemoApp to hold the render texture, the depth texture, and two views: Ref<RHI::IResource> rt_tex; Ref<RHI::IRenderTargetView> rtv; Ref<RHI::IResource> depth_tex; Ref<RHI::IDepthStencilView> dsv; Then we can create textures using the following code: auto window_size = window->get_framebuffer_size(); luset(rt_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, window_size.x, window_size.y, 1, 1))); luset(depth_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, window_size.x, window_size.y, 1, 1))); Note that when retrieving window size for rendering, we need to call IWindow::get_framebuffer_size instead of IWindow::get_size , on some platforms the window size is not necessary measured in pixels, causing these two methods return different values. We then need to create the render target view and depth stencil view for these two textures. Render target views and depth stencil views describes which portion of the texture will be bound to the graphic pipeline. Unlike other views, these two views are represented by dedicated objects: IRenderTargetView and IDepthStencilView , they can be created using the following code: luset(rtv, dev->new_render_target_view(rt_tex)); luset(dsv, dev->new_depth_stencil_view(depth_tex)); these two methods accepts additional RenderTargetViewDesc and DepthStencilViewDesc structures when creating views, but since we are using the default settings, these two structures can be omitted. Since we are using the window size as the render texture size, these textures should also be recreated when the window framebuffer is changed. This can be done by adding the following code to the DemoApp::resize method: luset(rt_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, width, height, 1, 1))); luset(depth_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, width, height, 1, 1))); luset(rtv, dev->new_render_target_view(rt_tex)); luset(dsv, dev->new_depth_stencil_view(depth_tex)); Creating buffers The next step is to create buffers used in our DemoApp , including: The vertex buffer and index buffer for our box mesh. The constant buffer for camera properties. Firstly we need to define the vertex structure of our box. Adding the following code after the declaration of DemoApp structure: struct Vertex { Float3U position; Float2U texcoord; }; Float2U and Float3U are vector types used in Luna SDK, which represent 2D and 3D vectors. In Luna SDK, we have 16-bytes aligned vector types Float2 , Float3 , Float4 , and unaligned vector types Float2U , Float3U and Float4U . The aligned vector types are used for calculations, SIMD functions like min , max , lerp , clamp only accepts aligned types, while unaligned vector types are used for storing and transferring data, such as in this case. The size of aligned vector types are all 16 bytes, while the size of unaligned types are 8, 12 and 16 for Float2U , Float3U and Float4U . We need to add three new properties to DemoApp to hold the these three buffers: Ref<RHI::IResource> vb; Ref<RHI::IResource> ib; Ref<RHI::IResource> cb; Then, we need to create the vertex buffer and index buffer for our box using the following code: Vertex vertices[] = { {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, +0.5, -0.5}, {0.0, 0.0}}, {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, -0.5, +0.5}, {1.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 1.0}}, {{+0.5, +0.5, +0.5}, {0.0, 0.0}}, {{-0.5, +0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 1.0}}, {{-0.5, -0.5, +0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}}, {{-0.5, +0.5, -0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}}, {{-0.5, -0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 0.0}}, {{+0.5, -0.5, -0.5}, {1.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}}, {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 1.0}}, {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}} }; u32 indices[] = { 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23 }; luset(vb, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::vertex_buffer, sizeof(vertices)))); luset(ib, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::index_buffer, sizeof(indices)))); void* mapped = nullptr; luexp(vb->map_subresource(0, false, &mapped)); memcpy(mapped, vertices, sizeof(vertices)); vb->unmap_subresource(0, true); luexp(ib->map_subresource(0, false, &mapped)); memcpy(mapped, indices, sizeof(indices)); ib->unmap_subresource(0, true); We firstly define vertex and index data for our box, then we create two buffer resources to hold the vertex and index data. Those two resources are created in shared_upload heap, so we can upload data to the resource, while still achieving maximum GPU bandwidth. After the resource is created, we can map the resource to system memory by calling IResource::map , and retrieving one pointer to the memory, then we use memcpy to copy buffer data, and use IResource::unmap to release the memory mapping, and store the data to the resource. We can use similar code to create the constant buffer for uploading camera properties, but there are two differences. First, the graphic device usually has alignment requirements for constant buffers, which can be fetched from IDevice::get_constant_buffer_data_alignment() , so we use align_upper helper function to adjust the size of our constant buffer resource to meet the alignment requirement. Second, since we need to update constant buffer data once every frame, we should choose upload heap instead of shared_upload for maximum CPU bandwidth. In our DemoApp , the data of the constant buffer is the 4x4 world-to-project matrix of the camera. We need to add a new include file to use matrix types: #include <Runtime/Math/Matrix.hpp> then we can use the following code to create constant buffer: auto cb_align = dev->get_constant_buffer_data_alignment(); luset(cb, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::upload, ResourceUsageFlag::constant_buffer, align_upper(sizeof(Float4x4), cb_align)))); as you can see, Float4x4 is the matrix type used in Luna SDK. We also have Float3x3 for 2D affine transformations. Loading image from file The next step is to load our Luna LOGO image that will be drawn on the box surface: Save the image file in the same directory as main.cpp , and naming it luna.png . You should have one file structure similar to this: DemoApp |- xmake.lua |- main.cpp |- luna.png Then fills xmake.lua with the following code: target(\"DemoApp\") set_luna_program() add_headerfiles(\"**.hpp\") add_files(\"**.cpp\") add_deps(\"Runtime\", \"Window\", \"RHI\", \"ShaderCompiler\", \"Image\") before_build(function(target) os.cp(\"$(scriptdir)/luna.png\", target:targetdir() .. \"/luna.png\") end) after_install(function (target) os.cp(target:targetdir() .. \"/luna.png\", target:installdir() .. \"/bin/luna.png\") end) target_end() This script triggers registers custom functions before building the program and after installing the program, the custom function copies the image file to same the directory of our program binary file, so that our program can correctly find the image file. We firstly need to add one new property to DemoApp to represent the loaded image: Ref<RHI::IResource> file_tex; To load the image in our program, we need to use one new module called Image , which parses image file data and gives row-majored image data in our desired format. We also need to use the file API provided by Runtime module, so we includes two new headers: #include <Runtime/File.hpp> #include <Image/Image.hpp> The first thing to do is to load image file data from our luna.png file. In order to load file data, we need to use the open_file function provided by the Runtime module. This function returns one file handle represented by IFile if the file is correctly opened. Then, we loads the file data into one Blob object by calling load_file_data , this function creates one properly-sized blob object, and calls IFile::read to read all data of the file to the blob, then returns the blob: lulet(image_file, open_file(\"Luna.png\", FileOpenFlag::read, FileCreationMode::open_existing)); lulet(image_file_data, load_file_data(image_file)); Now that the file data has been stored in image_file_data , we need to call Image::read_image_file function to parse the file data and gives the real image data: Image::ImageDesc image_desc; lulet(image_data, Image::read_image_file(image_file_data.data(), image_file_data.size(), Image::ImagePixelFormat::rgba8_unorm, image_desc)); Image::read_image_file function outputs one Image::ImageDesc structure that describes the returned image data, including the width, height and pixel format of the image. The image data is arranged in a row-major manner and without and alignment padding. We then creates one new resource, and uploads the data to the resource: luset(file_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::shared_upload, Format::rgba8_unorm, ResourceUsageFlag::shader_resource, image_desc.width, image_desc.height, 1, 1))); luexp(file_tex->map_subresource(0, false)); luexp(file_tex->write_subresource(0, image_data.data(), image_desc.width * Image::pixel_size(image_desc.format), image_desc.width * image_desc.height * Image::pixel_size(image_desc.format), BoxU(0, 0, 0, image_desc.width, image_desc.height, 1))); file_tex->unmap_subresource(0, true); Note that for texture resources, we cannot fetch pointers to the mapped data and copy data directly using memcpy like those in buffer resources. Instead, we need to call IResource::write_subresource after IResource::map_subresource to let the system copy data to the resource memory. The resource is created in shared_upload heap, which is the common option for resources whose data will be loaded from file. Set up descriptor set Once the constant buffer and file texture is set up, we can bind these two resources to the descriptor set that we need to bind to the pipeline state later. We also need to set the sampler in the descriptor set to be used by the pixel shader. desc_set->set_cbv(0, cb, ConstantBufferViewDesc(0, align_upper(sizeof(Float4x4), cb_align))); desc_set->set_srv(1, file_tex); desc_set->set_sampler(2, SamplerDesc(FilterMode::min_mag_mip_linear, TextureAddressMode::clamp, TextureAddressMode::clamp, TextureAddressMode::clamp, 0.0f, 1, ComparisonFunc::always, Float4U(0, 0, 0, 0), 0.0f, 0.0f)); This concludes the DemoApp::init function. Camera control Now that we have created all resources required to draw the box, we need to fill the actual drawing code in DemoApp::update . To make our program more interesting, we can apply one simple animation that rotates the camera around the box. We firstly adds one new property to DemoApp that stores the rotation angle of the camera: f32 camera_rotation = 0.0f; We can increase the rotation angle of the camera by one at every frame by adding the following line to the end of DemoApp:update : camera_rotation += 1.0f; Since we are going to use many functions that may throw errors, it is better to declare one lutry - lucatch scope that wraps all succeeding codes in DemoApp:update : RV DemoApp::update() { Window::poll_events(); if(window->is_closed()) return ok; lutry { camera_rotation += 1.0f; // More codes goes here... } lucatchret; return ok; } After we updates the camera rotation, we need to calculate the view-projection matrix for the camera. Fortunately, the math library of the Runtime module already includes implementations for many commonly used vector and matrix calculations, and here we are going to use two of them: AffineMatrix3D::make_look_at and perspective_projection_fov : Float3 camera_pos(cosf(camera_rotation / 180.0f * PI) * 2.0f, 1.0f, sinf(camera_rotation / 180.0f * PI) * 2.0f); Float4x4 camera_mat = AffineMatrix3D::make_look_at(camera_pos, Float3(0, 0, 0), Float3(0, 1, 0)); auto window_sz = window->get_framebuffer_size(); camera_mat = mul(camera_mat, perspective_projection_fov(PI / 3.0f, (f32)window_sz.x / (f32)window_sz.y, 0.001f, 100.0f)); The AffineMatrix3D namespace includes common functions for generating and decomposing 3D affine matrices. In our example, AffineMatrix3D::make_look_at generates one camera view matrix from the position of the camera and the position of the point to look at. perspective_projection_fov is another helper function that generates one projection matrix from the specified field-of-view and aspect ratio values. Those two matrices are multiplied by mul function to get the final view-projection matrix. Note that when performing matrix multiplications, use mul instead of operator * , the later one is used to multiply each element in the matrix separately. After we get the matrix, we can upload the matrix data to our constant buffer using the syntax similar to those for vertex and index buffers: void* camera_mapped; luexp(cb->map_subresource(0, false, &camera_mapped)); memcpy(camera_mapped, &camera_mat, sizeof(Float4x4)); cb->unmap_subresource(0, true); Resource barriers In Luna SDK, every graphic resource has one state that describes the current memory layout and pipeline access polity of the resource. Before we can issue draw calls, we need to transfer every resource we use to their correct states. Luna SDK requires the user to transfer the state explicitly by calling ICommandBuffer::resource_barriers with transition-typed resource barriers. In our example, we need to perform the following transitions: cmdbuf->resource_barriers({ ResourceBarrierDesc::as_transition(cb, ResourceState::vertex_and_constant_buffer), ResourceBarrierDesc::as_transition(vb, ResourceState::vertex_and_constant_buffer), ResourceBarrierDesc::as_transition(ib, ResourceState::index_buffer), ResourceBarrierDesc::as_transition(file_tex, ResourceState::shader_resource_pixel), ResourceBarrierDesc::as_transition(rt_tex, ResourceState::render_target), ResourceBarrierDesc::as_transition(depth_tex, ResourceState::depth_stencil_write) }); Luna SDK internally manages the current state for all resources, so we only need to specify the state of the resource after the transition. Luna SDK also omits unnecessary transitions automatically if the before and after state of one resource is same or compatible. Drawing the box Finally, we can issue the draw call that draws our box: RenderPassDesc desc; desc.rtvs[0] = rtv; desc.rt_load_ops[0] = LoadOp::clear; desc.rt_store_ops[0] = StoreOp::store; desc.rt_clear_values[0] = {0, 0, 0, 0}; desc.dsv = dsv; desc.depth_load_op = LoadOp::clear; desc.depth_store_op = StoreOp::store; desc.depth_clear_value = 1.0f; desc.stencil_load_op = LoadOp::dont_care; desc.stencil_store_op = StoreOp::dont_care; cmdbuf->begin_render_pass(desc); cmdbuf->set_graphic_shader_input_layout(slayout); cmdbuf->set_pipeline_state(pso); cmdbuf->set_graphic_descriptor_set(0, desc_set); cmdbuf->set_primitive_topology(PrimitiveTopology::triangle_list); auto sz = vb->get_desc().width_or_buffer_size; cmdbuf->set_vertex_buffers(0, {VertexBufferViewDesc(vb, 0, sz, sizeof(Vertex))}); sz = ib->get_desc().width_or_buffer_size; cmdbuf->set_index_buffer(ib, 0, sz, Format::r32_uint); cmdbuf->set_scissor_rect(RectI(0, 0, (i32)window_sz.x, (i32)window_sz.y)); cmdbuf->set_viewport(Viewport(0.0f, 0.0f, (f32)window_sz.x, (f32)window_sz.y, 0.0f, 1.0f)); cmdbuf->draw_indexed(36, 0, 0); cmdbuf->end_render_pass(); The first thing to do is to begin a render pass that attaches one set of render targets and/or the depth stencil target to the graphic pipeline, these render resources are bound to the pipeline during the current render pass and cannot be changed, while all other settings (like shader input layout object, pipeline state object, descriptor sets, etc) can be changed within the same render pass. The render pass begins with ICommandBuffer::begin_render_pass . In the render pass, we set up all pipeline settings, and bind all resources required for the current draw call, then calls ICommandBuffer::draw_indexed to issue the draw call based on the current settings. Then we should close the render pass by calling ICommandBuffer::end_render_pass . We won't go detail about the pipeline setup for this draw call, they should be familiar to you if you have been using other graphics API before. For further explanations, please consult the documentations for the RHI module. As we have said before, commands in the command buffer will not be executed immediately, they should be submitted to the command queue explicitly to get executed. So we do it here: luexp(cmdbuf->submit()); This transfers the command buffer to the execution state, so we can no longer adding commands to the command buffer until we reset the command buffer using ICommandBuffer::reset . Presenting the render result The last thing is to present our rendering result to the window (or precisely, the back buffer in the window swap chain), and this is done by calling ISwapChain::presnet : luexp(swap_chain->present(rt_tex, 0, 1)); The first two parameters are the texture resource and subresource id to get displayed, and the system will blit the texture to the back buffer. For compatibility reasons, the user cannot fetch the back buffer directly like in other graphic APIs, this will bring one extra blit overhead on some platforms, but it won't be the bottleneck of your program for most cases. In Luna SDK, the present call is not synchronous, it only pushes the present command into the bounding command queue and returns directly. We should explicitly wait for the present command to be finished by calling ISwapChain::wait before we can start the next frame: swap_chain->wait(); Since we submitted the command buffer before the present call, when the present command is finished, the command buffer is guaranteed to be finished, so that we don't need to call cmdbuf->wait() explicitly and can reset the command buffer safely now: luexp(cmdbuf->reset()); This concludes the DemoApp::update function. Build and run DemoApp , if everything goes correctly, you will see a textured rotating box in the screen: Congratulations! If you have followed every step of this article correctly, you should have a first impression of graphic programming using Luna SDK. If anything goes wrong, you can compare your code with the following reference code to identify the mistake. Reference code for main.cpp #include <Runtime/Runtime.hpp> #include <Runtime/Module.hpp> #include <Runtime/Debug.hpp> #include <Window/Window.hpp> #include <RHI/RHI.hpp> #include <ShaderCompiler/ShaderCompiler.hpp> #include <RHI/ShaderCompileHelper.hpp> #include <Runtime/Math/Matrix.hpp> #include <Runtime/File.hpp> #include <Image/Image.hpp> #include <Runtime/Math/Transform.hpp> using namespace Luna; struct DemoApp { Ref<Window::IWindow> window; Ref<RHI::IDevice> dev; Ref<RHI::ICommandQueue> queue; Ref<RHI::ICommandBuffer> cmdbuf; Ref<RHI::ISwapChain> swap_chain; Ref<RHI::IDescriptorSetLayout> dlayout; Ref<RHI::IDescriptorSet> desc_set; Ref<RHI::IShaderInputLayout> slayout; Ref<RHI::IPipelineState> pso; Ref<RHI::IResource> rt_tex; Ref<RHI::IRenderTargetView> rtv; Ref<RHI::IResource> depth_tex; Ref<RHI::IDepthStencilView> dsv; Ref<RHI::IResource> vb; Ref<RHI::IResource> ib; Ref<RHI::IResource> cb; Ref<RHI::IResource> file_tex; f32 camera_rotation = 0.0f; RV init(); RV update(); bool is_exiting(); RV resize(u32 width, u32 height); }; DemoApp* g_app = nullptr; struct Vertex { Float3U position; Float2U texcoord; }; RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); window->get_close_event() += [](Window::IWindow* window) { window->close(); }; window->get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) { lupanic_if_failed(g_app->resize(width, height)); }; dev = RHI::get_main_device(); using namespace RHI; luset(queue, dev->new_command_queue(CommandQueueType::graphic)); luset(cmdbuf, queue->new_command_buffer()); luset(swap_chain, new_swap_chain(queue, window, SwapChainDesc(0, 0, Format::rgba8_unorm, 2))); luset(dlayout, dev->new_descriptor_set_layout(DescriptorSetLayoutDesc({ {DescriptorType::cbv, 0, 1, ShaderVisibility::vertex}, {DescriptorType::srv, 1, 1, ShaderVisibility::pixel}, {DescriptorType::sampler, 2, 1, ShaderVisibility::pixel} }))); luset(desc_set, dev->new_descriptor_set(DescriptorSetDesc(dlayout))); const char vs_shader_code[] = R\"( cbuffer vertexBuffer : register(b0) { float4x4 world_to_proj; }; struct VS_INPUT { float3 position : POSITION; float2 texcoord : TEXCOORD; }; struct PS_INPUT { float4 position : SV_POSITION; float2 texcoord : TEXCOORD; }; PS_INPUT main(VS_INPUT input) { PS_INPUT output; output.position = mul(world_to_proj, float4(input.position, 1.0f)); output.texcoord = input.texcoord; return output; })\"; const char ps_shader_code[] = R\"( Texture2D tex : register(t1); SamplerState tex_sampler : register(s2); struct PS_INPUT { float4 position : SV_POSITION; float2 texcoord : TEXCOORD; }; float4 main(PS_INPUT input) : SV_Target { return float4(tex.Sample(tex_sampler, input.texcoord)); })\"; auto compiler = ShaderCompiler::new_compiler(); compiler->set_source({ vs_shader_code, strlen(vs_shader_code)}); compiler->set_source_name(\"DemoAppVS\"); compiler->set_entry_point(\"main\"); compiler->set_target_format(RHI::get_current_platform_shader_target_format()); compiler->set_shader_type(ShaderCompiler::ShaderType::vertex); compiler->set_shader_model(5, 0); compiler->set_optimization_level(ShaderCompiler::OptimizationLevel::full); luexp(compiler->compile()); auto vs_data = compiler->get_output(); Blob vs(vs_data.data(), vs_data.size()); compiler->reset(); compiler->set_source({ ps_shader_code, strlen(ps_shader_code)}); compiler->set_source_name(\"DemoAppPS\"); compiler->set_entry_point(\"main\"); compiler->set_target_format(RHI::get_current_platform_shader_target_format()); compiler->set_shader_type(ShaderCompiler::ShaderType::pixel); compiler->set_shader_model(5, 0); compiler->set_optimization_level(ShaderCompiler::OptimizationLevel::full); luexp(compiler->compile()); auto ps_data = compiler->get_output(); Blob ps(ps_data.data(), ps_data.size()); luset(slayout, dev->new_shader_input_layout(ShaderInputLayoutDesc({dlayout}, ShaderInputLayoutFlag::allow_input_assembler_input_layout | ShaderInputLayoutFlag::deny_hull_shader_access | ShaderInputLayoutFlag::deny_domain_shader_access | ShaderInputLayoutFlag::deny_geometry_shader_access))); GraphicPipelineStateDesc ps_desc; ps_desc.primitive_topology_type = PrimitiveTopologyType::triangle; ps_desc.sample_mask = U32_MAX; ps_desc.sample_quality = 0; ps_desc.blend_state = BlendDesc(false, false, { RenderTargetBlendDesc(false, false, BlendFactor::src_alpha, BlendFactor::inv_src_alpha, BlendOp::add, BlendFactor::inv_src_alpha, BlendFactor::zero, BlendOp::add, LogicOp::noop, ColorWriteMask::all) }); ps_desc.rasterizer_state = RasterizerDesc(FillMode::solid, CullMode::back, 0, 0.0f, 0.0f, 0, false, true, false, false, false); ps_desc.depth_stencil_state = DepthStencilDesc(true, true, ComparisonFunc::less_equal, false, 0x00, 0x00, DepthStencilOpDesc(), DepthStencilOpDesc()); ps_desc.ib_strip_cut_value = IndexBufferStripCutValue::disabled; ps_desc.input_layout = InputLayoutDesc({ {\"POSITION\", 0, Format::rgb32_float}, {\"TEXCOORD\", 0, Format::rg32_float}, }); ps_desc.vs = vs.cspan(); ps_desc.ps = ps.cspan(); ps_desc.shader_input_layout = slayout; ps_desc.num_render_targets = 1; ps_desc.rtv_formats[0] = Format::rgba8_unorm; ps_desc.dsv_format = Format::d32_float; luset(pso, dev->new_graphic_pipeline_state(ps_desc)); auto window_size = window->get_framebuffer_size(); luset(rt_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, window_size.x, window_size.y, 1, 1))); luset(depth_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, window_size.x, window_size.y, 1, 1))); luset(rtv, dev->new_render_target_view(rt_tex)); luset(dsv, dev->new_depth_stencil_view(depth_tex)); Vertex vertices[] = { {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, +0.5, -0.5}, {0.0, 0.0}}, {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, -0.5, +0.5}, {1.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 1.0}}, {{+0.5, +0.5, +0.5}, {0.0, 0.0}}, {{-0.5, +0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 1.0}}, {{-0.5, -0.5, +0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}}, {{-0.5, +0.5, -0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}}, {{-0.5, -0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 0.0}}, {{+0.5, -0.5, -0.5}, {1.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}}, {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 1.0}}, {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}} }; u32 indices[] = { 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23 }; luset(vb, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::vertex_buffer, sizeof(vertices)))); luset(ib, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::index_buffer, sizeof(indices)))); void* mapped = nullptr; luexp(vb->map_subresource(0, false, &mapped)); memcpy(mapped, vertices, sizeof(vertices)); vb->unmap_subresource(0, true); luexp(ib->map_subresource(0, false, &mapped)); memcpy(mapped, indices, sizeof(indices)); ib->unmap_subresource(0, true); auto cb_align = dev->get_constant_buffer_data_alignment(); luset(cb, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::upload, ResourceUsageFlag::constant_buffer, align_upper(sizeof(Float4x4), cb_align)))); lulet(image_file, open_file(\"Luna.png\", FileOpenFlag::read, FileCreationMode::open_existing)); lulet(image_file_data, load_file_data(image_file)); Image::ImageDesc image_desc; lulet(image_data, Image::read_image_file(image_file_data.data(), image_file_data.size(), Image::ImagePixelFormat::rgba8_unorm, image_desc)); luset(file_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::shared_upload, Format::rgba8_unorm, ResourceUsageFlag::shader_resource, image_desc.width, image_desc.height, 1, 1))); luexp(file_tex->map_subresource(0, false)); luexp(file_tex->write_subresource(0, image_data.data(), image_desc.width * Image::pixel_size(image_desc.format), image_desc.width * image_desc.height * Image::pixel_size(image_desc.format), BoxU(0, 0, 0, image_desc.width, image_desc.height, 1))); file_tex->unmap_subresource(0, true); desc_set->set_cbv(0, cb, ConstantBufferViewDesc(0, align_upper(sizeof(Float4x4), cb_align))); desc_set->set_srv(1, file_tex); desc_set->set_sampler(2, SamplerDesc(FilterMode::min_mag_mip_linear, TextureAddressMode::clamp, TextureAddressMode::clamp, TextureAddressMode::clamp, 0.0f, 1, ComparisonFunc::always, Float4U(0, 0, 0, 0), 0.0f, 0.0f)); } lucatchret; return ok; } RV DemoApp::update() { Window::poll_events(); if(window->is_closed()) return ok; lutry { camera_rotation += 1.0f; Float3 camera_pos(cosf(camera_rotation / 180.0f * PI) * 2.0f, 1.0f, sinf(camera_rotation / 180.0f * PI) * 2.0f); Float4x4 camera_mat = AffineMatrix3D::make_look_at(camera_pos, Float3(0, 0, 0), Float3(0, 1, 0)); auto window_sz = window->get_framebuffer_size(); camera_mat = mul(camera_mat, perspective_projection_fov(PI / 3.0f, (f32)window_sz.x / (f32)window_sz.y, 0.001f, 100.0f)); void* camera_mapped; luexp(cb->map_subresource(0, false, &camera_mapped)); memcpy(camera_mapped, &camera_mat, sizeof(Float4x4)); cb->unmap_subresource(0, true); using namespace RHI; cmdbuf->resource_barriers({ ResourceBarrierDesc::as_transition(cb, ResourceState::vertex_and_constant_buffer), ResourceBarrierDesc::as_transition(vb, ResourceState::vertex_and_constant_buffer), ResourceBarrierDesc::as_transition(ib, ResourceState::index_buffer), ResourceBarrierDesc::as_transition(file_tex, ResourceState::shader_resource_pixel), ResourceBarrierDesc::as_transition(rt_tex, ResourceState::render_target), ResourceBarrierDesc::as_transition(depth_tex, ResourceState::depth_stencil_write) }); RenderPassDesc desc; desc.rtvs[0] = rtv; desc.rt_load_ops[0] = LoadOp::clear; desc.rt_store_ops[0] = StoreOp::store; desc.rt_clear_values[0] = {0, 0, 0, 0}; desc.dsv = dsv; desc.depth_load_op = LoadOp::clear; desc.depth_store_op = StoreOp::store; desc.depth_clear_value = 1.0f; desc.stencil_load_op = LoadOp::dont_care; desc.stencil_store_op = StoreOp::dont_care; cmdbuf->begin_render_pass(desc); cmdbuf->set_graphic_shader_input_layout(slayout); cmdbuf->set_pipeline_state(pso); cmdbuf->set_graphic_descriptor_set(0, desc_set); cmdbuf->set_primitive_topology(PrimitiveTopology::triangle_list); auto sz = vb->get_desc().width_or_buffer_size; cmdbuf->set_vertex_buffers(0, {VertexBufferViewDesc(vb, 0, sz, sizeof(Vertex))}); sz = ib->get_desc().width_or_buffer_size; cmdbuf->set_index_buffer(ib, 0, sz, Format::r32_uint); cmdbuf->set_scissor_rect(RectI(0, 0, (i32)window_sz.x, (i32)window_sz.y)); cmdbuf->set_viewport(Viewport(0.0f, 0.0f, (f32)window_sz.x, (f32)window_sz.y, 0.0f, 1.0f)); cmdbuf->draw_indexed(36, 0, 0); cmdbuf->end_render_pass(); luexp(cmdbuf->submit()); luexp(swap_chain->present(rt_tex, 0, 1)); swap_chain->wait(); luexp(cmdbuf->reset()); } lucatchret; return ok; } bool DemoApp::is_exiting() { return window->is_closed(); } RV DemoApp::resize(u32 width, u32 height) { lutry { using namespace RHI; auto dev = get_main_device(); luexp(swap_chain->resize_buffers(2, width, height, Format::rgba8_unorm)); luset(rt_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, width, height, 1, 1))); luset(depth_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, width, height, 1, 1))); luset(rtv, dev->new_render_target_view(rt_tex)); luset(dsv, dev->new_depth_stencil_view(depth_tex)); } lucatchret; return ok; } RV run_app() { auto result = init_modules(); if(failed(result)) return result; g_app = memnew<DemoApp>(); result = g_app->init(); if(failed(result)) return result; while(!g_app->is_exiting()) { result = g_app->update(); if(failed(result)) return result; } return ok; } int main() { bool initialized = Luna::init(); if(!initialized) return -1; RV result = run_app(); if(failed(result)) debug_printf(explain(result.errcode())); if(g_app) memdelete(g_app); Luna::close(); return 0; } Reference code for xmake.lua target(\"DemoApp\") set_luna_program() add_headerfiles(\"**.hpp\") add_files(\"**.cpp\") add_deps(\"Runtime\", \"Window\", \"RHI\", \"ShaderCompiler\", \"Image\") before_build(function(target) os.cp(\"$(scriptdir)/luna.png\", target:targetdir() .. \"/luna.png\") end) after_install(function (target) os.cp(target:targetdir() .. \"/luna.png\", target:installdir() .. \"/bin/luna.png\") end) target_end()","title":"Getting Started"},{"location":"manual/introduction/getting_started/#getting-started","text":"Welcome to Luna SDK. In this article, we will guide you to Luna SDK by creating a simple program that draws one textured 3D cube on the screen. At the end of this article, you will have a basic understanding of using Luna SDK to create a simple graphic program, and can start to explore more advanced features provided by Luna SDK.","title":"Getting Started"},{"location":"manual/introduction/getting_started/#prerequisites","text":"In this article, we assume that you have the basic knowledge of C++ programming and graphics programming (like using D3D11, D3D12 or OpenGL). You should also correctly setup Luna SDK and developing environments using the instructions provided in README.md of the project.","title":"Prerequisites"},{"location":"manual/introduction/getting_started/#creating-the-program","text":"The first thing to do is to create an binary target for our demo program, so that XMake build system can correctly build our program. To create a new program, create a new folder in the {LUNA_ROOT_DIR}/Programs directory, and name it DemoApp . In this folder, create a new Lua script file called xmake.lua , and fill its content with the following text: target(\"DemoApp\") set_luna_program() add_files(\"**.cpp\") add_deps(\"Runtime\", \"Window\", \"RHI\", \"ShaderCompiler\", \"Image\") target_end() target and target_end enclose a target scope , where all target definitions are specified. set_luna_program tells XMake that we are defining one Luna SDK program, this will let XMake set the target kind to \"binary\" and import all SDK options for the program. add_files(\"**.cpp\") tells XMake to add all CPP files in the current directory and all subdirectories to the this target. add_deps lists all libraries that this program links to, in our example, we need to link to the SDK runtime ( Runtime ), the window module ( Window ) , the Graphics API module ( RHI ), the shader compiler module ( ShaderCompiler ) and the image file module ( Image ). If you got unresolved external symbol errors when compiling, make sure you already link correct libraries. Then we need to create source CPP files for our program. Since out demo program is simple, we only create one \"main.cpp\" file to host all source codes. After this, the DemoApp directory should looks like this: DemoApp |- xmake.lua |- main.cpp The last thing is to add one line in the end of {LUNA_ROOT_DIR}/Programs/xmake.lua to tell XMake to add our program in the solution: includes(\"DemoApp\") Well done, now every is set up and we can start to program our first Luna SDK program!","title":"Creating the program"},{"location":"manual/introduction/getting_started/#program-structure","text":"Next, fills main.cpp with the following initial content. As we go further, we will add more properties and methods to our DemoApp structure, while remaining the rest part unchanged. #include <Runtime/Runtime.hpp> #include <Runtime/Module.hpp> #include <Runtime/Debug.hpp> using namespace Luna; struct DemoApp { RV init(); RV update(); bool is_closed(); }; DemoApp* g_app = nullptr; RV DemoApp::init() { return ok; } RV DemoApp::update() { return ok; } bool DemoApp::is_closed() { return false; } RV run_app() { auto result = init_modules(); if(failed(result)) return result; g_app = memnew<DemoApp>(); result = g_app->init(); if(failed(result)) return result; while(!g_app->is_closed()) { result = g_app->update(); if(failed(result)) return result; } return ok; } int main() { bool initialized = Luna::init(); if(!initialized) return -1; RV result = run_app(); if(failed(result)) debug_printf(explain(result.errcode())); if(g_app) memdelete(g_app); Luna::close(); return 0; } The first three lines includes the header files that we need to include to compile the program, which are: * for Luna::init() and Luna::shutdown() . for Luna::init_modules() . for Luna::debug_printf() . You can include any SDK interface header files using similar syntax: #include <Module/File> . We set {LUNA_ROOT_DIR}/Engine as the global include directory, the user may check it for available header files. In this example, all header files are from the Runtime module, which is the core module of Luna SDK that provides fundamental SDK features. The next statement is using namespace Luna . In Luna SDK, all types, functions and variables are defined in Luna namespace, and every module will define its elements in nested namespace, such as Luna::RHI . So, we use this statement to prevent spelling the Luna:: namespace prefix in our following code. The program starts with the main function, just like any normal C/C++ program. In the main function, we firstly call Luna::init to initialize Luna SDK. This function should be called before any other Luna SDK function. Luna::init returns one Boolean value to indicate whether the SDK initialization is succeeded, if the return value is false , we then return -1 and exit the program to indicate one runtime error. If Luna::init returns true , then one Luna::close call is need before the program exit to let the SDK clean up all internal resources. We then wrap the real program logic in one run_app function. The return type of run_app is RV , which is a shortcut for R<void> , this is part of the error handling mechanism of Luna SDK. R<T> is a structure that encapsulates one return value with type T and one error code with type ErrCode , which is simply an alias of usize (or std::size_t ). If the function succeeds, the returned value will be one T -typed value and one error code 0 ; if the function fails, the returned value will be one non-zero error code, and the T -typed value will be uninitialized and inaccessible, you may call errcode() to fetch the error code from R<T> , and may call explain to get a brief description of the error. In our main function, we check whether our run_app function is failed by using failed helper function (there is also one succeeded helper function available), then we print the error description and exits the program if any error occurs. In our run_app function, the first thing to do is calling init_modules , which will initialize all linked SDK modules for our program. We deliberately separate module initialization from Luna::init so that the user get a chance to set module initialization parameters before initializing modules, and modules can also indicate initialization failure by returning error codes (error handling system is available after Luna::init ). Then, we allocate and initialize one new object of DemoApp type by calling memnew function. The following table shows memory allocation functions used in Luna SDK: Luna SDK functions C++ functions/keywords memalloc(size, alignment) malloc(size) memfree(ptr, alignment) free(ptr) memrealloc(ptr, size, alignment) realloc(ptr, size) memsize(size, alignment) N/A memnew<T>(args...) new T (args...) memdelete(ptr) delete ptr The user should uses allocation functions provided by Luna SDK instead of those provided by C++ std. DemoApp will contain all states and logics for our demo program. The created DempApp instance then will be assigned to a global variable g_app , and will be deleted by memdelete when the program exits. DemoApp has three functions: init , update and is_closed . The init function initializes the program, and reports errors if the initialization is failed; the update function updates the program state and renders the image at every frame; the is_exiting function checks whether the program is exiting. We will implement these three methods in the following sections. The rest part of our run_app function simply checks whether the program is exiting by calling is_exiting , and updates the program when it is not exiting. After filling this content, execute xmake build DemoApp on terminal or click build button on your IDE, you should successfully build the DemoApp program.","title":"Program structure"},{"location":"manual/introduction/getting_started/#window-creation-and-event-handling","text":"Now that we have one basic program structure, we need to create a system window so that we can render images to it. We also need to implement window event handling so that the program can exit when the user clicks the close button of the window. Window creation is fairly simple, we firstly need to introduce one new header: #include <Window/Window.hpp> then we add one new property to our DemoApp structure: struct DemoApp { Ref<Window::IWindow> window; RV init(); RV update(); bool is_exiting(); RV resize(u32 width, u32 height); }; The window object is provided by Window::IWindow* interface pointer in Luna SDK, which points to a boxed object which manages its lifetime using reference counting . IWindow interface may have different implementations on different platforms, by they all provide the same functionality required by this interface. Ref<T> is a smart pointer for boxed objects, it will manage the reference counter of the pointing object automatically when being constructed and destructed, so the user does not need to call object_retain and object_release manually. You may compare Ref<T> to ComPtr used in Microsoft's Component-Object Model (COM), or the automatic reference counting in Apple's Objective-C and Swift. The default constructor of Ref<T> initializes the pointer to nullptr , so we need to assign it with a valid object. Then we need to create our window in DemoApp::init : RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); } lucatch { return lures; } return ok; } Besides the new_window function that creates the window, there are four new keywords in our code: lutry , lucatch , luset and lures . These four keywords are macros that enables us to write error handling using a simpler try-catch style, rather than fetching and checking error codes once and once again for every function call that may fail. lutry and lucatch must be used in pairs, next to each other. In the lutry block, the user may define multiple lulet , luset or luexp statements, lulet statement creates a new local variable to hold the return value of the function, and jumps to lucatch if the function fails; luset assigns the return value to one existing variable, and jumps to lucatch if the function fails; luexp is used if the function does not return any value, it simply checks whether the function succeeds, and jumps to lucatch if not. The user may also call luthrow manually in lutry block to jump to lucatch directly. In the lucatch block, lures is provided as the error code that causes the failure. You may use one switch statement on the lures to handle specific errors, or you can propagate the error directly to parent function by return lures . Since error propagating is so commonly used, we create another macro lucatchret to replace lucatch { return lures; } , so the code above can be written as: RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); } lucatchret; return ok; } Since we use goto statement to implement lutry and lucatch , it you needs multiple lutry-lucatch pairs in one function, you should use a numbered version for every pair (like lutry2 , lucatch2 , luset 2, lures2 , etc.). In most cases, only one lutry-lucatch pair is sufficient. Now let's get back to Window::new_window function that does the actual work. The function signature of this function is: R<Ref<IWindow>> new_window(const c8* title, i32 x, i32 y, i32 width, i32 height, monitor_t monitor = nullptr, WindowCreationFlag flags = WindowCreationFlag::none) Most parameters are self-explained, monitor is one handle to one system monitor, if you need to create a full-screen window, you need to specify the monitor to create window for, otherwise just leave it nullptr . flags are a combination of WindowCreationFlag enumeration class that lists flags for window creation process. If WindowCreationFlag::position_center is set, then x and y will be ignored and the window will be positioned on the center of the primary monitor; if Window::WindowCreationFlag::default_size is set, then width and height will be ignored and the window size will be set to a proper value based on the primary monitor's resolution. After the window is created, we need to register window event callbacks so that we can handle window events properly. In this example, the events we need to handle is the close event (triggered when the close button of the window is pressed) and the framebuffer resize event (triggered when the window framebuffer size is changed). This can be done by the following statements: window->get_close_event() += [](Window::IWindow* window) { window->close(); }; window->get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) { lupanic_if_failed(g_app->resize(width, height)); }; get_close_event and get_framebuffer_resize_event are methods of IWindow that gets the close event and the framebuffer resize event object of the window. The event object is a collection of callback functions that once triggered, calls all the callback functions. We then register one callback function to the close event that closes the window immediately, and one callback function to the framebuffer resize event that calls the resize method of our DempApp . The resize method is currently empty, we will fill the content of this method when we create render textures later: RV DemoApp::resize(u32 width, u32 height) { return ok; } Window events are not polled automatically, we need to tell the window system to poll events at every frame by calling Window::poll_events in update function: RV DemoApp::update() { Window::poll_events(); return ok; } This call polls events for all existing windows, so we don't need to provide specific window here. After we correctly handle the close event, we can complete the is_closed method of DemoApp : bool DemoApp::is_exiting() { return window->is_closed(); } So far, the complete code for main.cpp is: #include <Runtime/Runtime.hpp> #include <Runtime/Module.hpp> #include <Runtime/Debug.hpp> #include <Window/Window.hpp> using namespace Luna; struct DemoApp { Ref<Window::IWindow> window; RV init(); RV update(); bool is_exiting(); RV resize(u32 width, u32 height); }; DemoApp* g_app = nullptr; RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); window->get_close_event() += [](Window::IWindow* window) { window->close(); }; window->get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) { lupanic_if_failed(g_app->resize(width, height)); }; } lucatchret; return ok; } RV DemoApp::update() { Window::poll_events(); return ok; } bool DemoApp::is_exiting() { return window->is_closed(); } RV DemoApp::resize(u32 width, u32 height) { return ok; } RV run_app() { auto result = init_modules(); if(failed(result)) return result; g_app = memnew<DemoApp>(); result = g_app->init(); if(failed(result)) return result; while(!g_app->is_exiting()) { result = g_app->update(); if(failed(result)) return result; } return ok; } int main() { bool initialized = Luna::init(); if(!initialized) return -1; RV result = run_app(); if(failed(result)) debug_printf(explain(result.errcode())); if(g_app) memdelete(g_app); Luna::close(); return 0; } Build and run DemoApp , and you will see a blank window appears, and the program exits when you click the close button of the window.","title":"Window creation and event handling"},{"location":"manual/introduction/getting_started/#fetching-graphic-device","text":"After the window is created, we can start drawing our box. In Luna SDK, all graphic resources are related to one specific graphic device represented by RHI::IDevice , which is the virtual representation of the physical graphic device on the platform, so we need to add one property to DemoApp to hold this device: Ref<RHI::IDevice> dev; When RHI module initializes, it automatically chooses the most suitable physical device and creates one device for you, which can be fetched by RHI::get_main_device() . You may also create additional devices for special use, but in our DemoApp , we will stick to the default one by adding the following line in the lutry scope of DemoApp::init : dev = RHI::get_main_device(); We can also import all RHI types and functions by using namespace RHI; so that we don't need to spell them all over the init function: using namespace RHI; The code of DemoApp::init should look similar to: RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); window->get_close_event() += [](Window::IWindow* window) { window->close(); }; window->get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) { lupanic_if_failed(g_app->resize(width, height)); }; dev = RHI::get_main_device(); using namespace RHI; // New resource creation code goes here... } lucatchret; return ok; } Unless explicitly specified, all codes we need to add to DemoApp::init in the following sections are added to the end of lutry scope, not in the end of the function scope directly.","title":"Fetching graphic device"},{"location":"manual/introduction/getting_started/#creating-command-queue-and-command-buffer","text":"Luna SDK employs deferred execution model , where render and compute calls are recorded as commands in command buffers , then submitted to GPU explicitly by submitting command buffers to command queues . The command buffer object manages memory allocated to store commands, it also tracks the execution state for commands in the buffer when the buffer is submitted for execution. The command queue object is a FIFO message buffer between CPU and GPU. CPU can push command buffers into the queue, and GPU will pop command buffers from the queue and execute commands in the buffer. Command buffers in the queue are guaranteed to execute one after another, the next command buffer will not being executed until the last command buffer is finished. We need to add two new properties to DemoApp to hold the command queue and command buffer: Ref<RHI::ICommandQueue> queue; Ref<RHI::ICommandBuffer> cmdbuf; Then we can create the objects by adding the following codes to DemoApp::init : luset(queue, dev->new_command_queue(CommandQueueType::graphic)); luset(cmdbuf, queue->new_command_buffer()); When creating command queues, we must specify the type of the queue. There are three different queue types: graphic , compute and copy . The copy queue only accepts copy commands, and is used for transferring data between different resources; the compute queue accepts copy and compute tasks, while the graphic queue accepts graphic, compute and copy commands. In our case, we need to create one graphic queue. Note that command buffers are created from command queues, not from the graphic device directly. Once the command buffer is created, it is bound to the queue who created the buffer, and the binding can not be changed.","title":"Creating command queue and command buffer"},{"location":"manual/introduction/getting_started/#creating-swap-chain","text":"The swap chain object contains resources that are used to present render results to our window. We need to add one new property to DemoApp to hold the command queue and command buffer: Ref<RHI::ISwapChain> swap_chain; In Luna SDK, the swap chain presentation is also a command that should be submitted using graphic command queues, so we need to specify the command queue we need to use when creating swap chains like so: luset(swap_chain, new_swap_chain(queue, window, SwapChainDesc(0, 0, Format::rgba8_unorm, 2))); The swap chain is described by one SwapChainDesc structure: struct SwapChainDesc { u32 width; u32 height; Format pixel_format; u32 buffer_count; }; When used for creating swap chains, you may pass 0 for width and height property, which indicates the system to use the window framebuffer size as the size of the swap chain. The swap chain needs to be resized when the window framebuffer size is changed. This can be done by filling DemoApp::resize method with the following codes: RV DemoApp::resize(u32 width, u32 height) { lutry { using namespace RHI; auto dev = get_main_device(); luexp(swap_chain->resize_buffers(2, width, height, Format::rgba8_unorm)); } lucatchret; return ok; } ISwapChain::resize_buffers will recreate the swap chain buffer according to the new window framebuffer size.","title":"Creating swap chain"},{"location":"manual/introduction/getting_started/#creating-descriptor-set-layout-and-descriptor-set","text":"The descriptor set object stores descriptors that bind resources to graphic or compute pipeline. Descriptors have the following types: Constant buffer view, which binds constant global data to shaders. Shader resource view, which binds read-only textures and structured buffers to shaders. Unordered access view, which binds writable resources to compute shaders. Sampler, which stores sampling settings and exposes those settings for shaders. Every pipeline may bind multiple descriptor sets, every descriptor set may contain all four kinds of descriptors listed above. The descriptor set layout object stores the layout of one descriptor set object, including the number of descriptors in the descriptor set and the property of each descriptor. In order to create one descriptor set layout object, we need to fill one DescriptorSetLayoutDesc structure. Here is the definition of DescriptorSetLayoutDesc structure: struct DescriptorSetLayoutDesc { Vector<DescriptorSetLayoutBinding> bindings; DescriptorSetLayoutFlag flags = DescriptorSetLayoutFlag::none; }; The descriptor set layout consists of multiple bindings specified by DescriptorSetLayoutBinding , each binding describes one range of the descriptor set: struct DescriptorSetLayoutBinding { DescriptorType type; u32 binding_slot; u32 num_descs; ShaderVisibility shader_visibility; }; the type property describes the type of this binding. All descriptors in the same binding must be the same type: enum class DescriptorType : u32 { srv, uav, cbv, sampler }; binding_slot and num_descs describes the binding slot range of this binding, starting from 0 . All slots in [binding_slot, binding_slot + num_descs) will be occupied by this binding and cannot be used by other bindings. If num_descs is greater than 1 , then this binding will be interpreted as one descriptor array in the shader. shader_visibility specifies which shader may access descriptors in this binding, you may restrict the visibility of one binding to one specific shader to potentially improve performance. We need to add two new properties to DemoApp to hold the descriptor set layout object and the descriptor set object: Ref<RHI::IDescriptorSetLayout> dlayout; Ref<RHI::IDescriptorSet> desc_set; We need 1 descriptor set with 1 constant buffer view, 1 shader resource view and 1 sampler. So we can create our descriptor set layout object in DemoApp::init like so: luset(dlayout, dev->new_descriptor_set_layout(DescriptorSetLayoutDesc({ {DescriptorType::cbv, 0, 1, ShaderVisibility::vertex}, {DescriptorType::srv, 1, 1, ShaderVisibility::pixel}, {DescriptorType::sampler, 2, 1, ShaderVisibility::pixel} }))); Then we can create one descriptor set using the descriptor set layout object: luset(desc_set, dev->new_descriptor_set(DescriptorSetDesc(dlayout))); We will fill descriptors in the set by calling set_cbv , set_srv and set_sampler later.","title":"Creating descriptor set layout and descriptor set"},{"location":"manual/introduction/getting_started/#compiling-shaders","text":"The next thing to do is compiling shaders for the pipeline state object. Luna SDK uses HLSL as the source shader language, and uses ShaderCompiler module to compile HLSL to DXBC, DXIL, SPIR-V and other target shading languages. To compile shader, we need to include corresponding header files: #include <ShaderCompiler/ShaderCompiler.hpp> #include <RHI/ShaderCompileHelper.hpp> ShaderCompileHelper.hpp includes RHI::get_current_platform_shader_target_format() function, which tell the shader compiler the native target target shader format for the current graphic API. Since our shader is rather simple, we declare our shader source code directly in the C++ source file, in DemoApp::init function: const char vs_shader_code[] = R\"( cbuffer vertexBuffer : register(b0) { float4x4 world_to_proj; }; struct VS_INPUT { float3 position : POSITION; float2 texcoord : TEXCOORD; }; struct PS_INPUT { float4 position : SV_POSITION; float2 texcoord : TEXCOORD; }; PS_INPUT main(VS_INPUT input) { PS_INPUT output; output.position = mul(world_to_proj, float4(input.position, 1.0f)); output.texcoord = input.texcoord; return output; })\"; const char ps_shader_code[] = R\"( Texture2D tex : register(t1); SamplerState tex_sampler : register(s2); struct PS_INPUT { float4 position : SV_POSITION; float2 texcoord : TEXCOORD; }; float4 main(PS_INPUT input) : SV_Target { return float4(tex.Sample(tex_sampler, input.texcoord)); })\"; here we use C++ raw string syntax R\"()\" to declare multiline string without appending \\ for every string line. Note the register number specified in shader must match the binding slot specified in descriptor set layout we just created. Since we use the same slot numbering system for all descriptor types, the register number for b , t , u and s should not overlap. Then we can compile shaders using ShaderCompiler::ICompiler object: auto compiler = ShaderCompiler::new_compiler(); compiler->set_source({ vs_shader_code, strlen(vs_shader_code) }); compiler->set_source_name(\"DemoAppVS\"); compiler->set_entry_point(\"main\"); compiler->set_target_format(RHI::get_current_platform_shader_target_format()); compiler->set_shader_type(ShaderCompiler::ShaderType::vertex); compiler->set_shader_model(5, 0); compiler->set_optimization_level(ShaderCompiler::OptimizationLevel::full); luexp(compiler->compile()); auto vs_data = compiler->get_output(); Blob vs(vs_data.data(), vs_data.size()); compiler->reset(); compiler->set_source({ ps_shader_code, strlen(ps_shader_code) }); compiler->set_source_name(\"DemoAppPS\"); compiler->set_entry_point(\"main\"); compiler->set_target_format(RHI::get_current_platform_shader_target_format()); compiler->set_shader_type(ShaderCompiler::ShaderType::pixel); compiler->set_shader_model(5, 0); compiler->set_optimization_level(ShaderCompiler::OptimizationLevel::full); luexp(compiler->compile()); auto ps_data = compiler->get_output(); Blob ps(ps_data.data(), ps_data.size()); The shader compilation process is fairly simple, we just set source code, compilation settings, then triggers the compilation. The compilation result will be given by get_output , we use one Blob object , a container for binary data, to hold the compilation result. The compiled shader data will be used when creating pipeline state object later.","title":"Compiling shaders"},{"location":"manual/introduction/getting_started/#creating-shader-input-layout-and-pipeline-state","text":"The graphic and compute pipeline state is described by two objects: shader input layout object and pipeline state object. Shader input layout object stores the shader binding layout information for all shader stages, while pipeline state object stores pipeline settings for all graphic stages. Shader input layout is described by the ShaderInputLayoutDesc structure, which is set by specifying layouts of descriptor sets that will be bound to this pipeline and flags that specifies shaders that are allowed to access shader inputs. struct ShaderInputLayoutDesc { Vector<IDescriptorSetLayout*> descriptor_set_layouts; ShaderInputLayoutFlag flags; }; We need to add one new property to DemoApp to hold the shader input layout object: Ref<RHI::IShaderInputLayout> slayout; Then we can create shader input layout object using the following code: luset(slayout, dev->new_shader_input_layout(ShaderInputLayoutDesc({dlayout}, ShaderInputLayoutFlag::allow_input_assembler_input_layout | ShaderInputLayoutFlag::deny_hull_shader_access | ShaderInputLayoutFlag::deny_domain_shader_access | ShaderInputLayoutFlag::deny_geometry_shader_access))); The pipeline object is described by the GraphicPipelineStateDesc structure or the ComputePipelineStateDesc structure. Since we are creating one graphic pipeline, we need to fill the GraphicPipelineStateDesc structure, which is a complex structure that contains all pipeline settings for one graphic pipeline: struct GraphicPipelineStateDesc { InputLayoutDesc input_layout; IShaderInputLayout* shader_input_layout = nullptr; Span<const byte_t> vs; Span<const byte_t> ps; Span<const byte_t> ds; Span<const byte_t> hs; Span<const byte_t> gs; StreamOutputDesc stream_output; BlendDesc blend_state; RasterizerDesc rasterizer_state; DepthStencilDesc depth_stencil_state; IndexBufferStripCutValue ib_strip_cut_value = IndexBufferStripCutValue::disabled; PrimitiveTopologyType primitive_topology_type = PrimitiveTopologyType::triangle; u32 num_render_targets = 0; Format rtv_formats[8] = { Format::unknown }; Format dsv_format = Format::unknown; u32 sample_count = 1; u32 sample_mask = 0xFFFFFFFF; u32 sample_quality = 0; }; Most graphic settings are similar to those in D3D11, D3D12, OpenGL or Vulkan, we will not explain these settings, but only gives the code that correctly sets every setting of the pipeline. You can see docs for RHI module for detailed explanations of these settings. We need to add one new property to DemoApp to hold the pipeline state object: Ref<RHI::IPipelineState> pso; Then we can create pipeline state object using the following code: GraphicPipelineStateDesc ps_desc; ps_desc.primitive_topology_type = PrimitiveTopologyType::triangle; ps_desc.sample_mask = U32_MAX; ps_desc.sample_quality = 0; ps_desc.blend_state = BlendDesc(false, false, { RenderTargetBlendDesc(false, false, BlendFactor::src_alpha, BlendFactor::inv_src_alpha, BlendOp::add, BlendFactor::inv_src_alpha, BlendFactor::zero, BlendOp::add, LogicOp::noop, ColorWriteMask::all) }); ps_desc.rasterizer_state = RasterizerDesc(FillMode::solid, CullMode::back, 0, 0.0f, 0.0f, 0, false, true, false, false, false); ps_desc.depth_stencil_state = DepthStencilDesc(true, true, ComparisonFunc::less_equal, false, 0x00, 0x00, DepthStencilOpDesc(), DepthStencilOpDesc()); ps_desc.ib_strip_cut_value = IndexBufferStripCutValue::disabled; ps_desc.input_layout = InputLayoutDesc({ {\"POSITION\", 0, Format::rgb32_float}, {\"TEXCOORD\", 0, Format::rg32_float}, }); ps_desc.vs = vs.cspan(); ps_desc.ps = ps.cspan(); ps_desc.shader_input_layout = slayout; ps_desc.num_render_targets = 1; ps_desc.rtv_formats[0] = Format::rgba8_unorm; ps_desc.dsv_format = Format::d32_float; luset(pso, dev->new_graphic_pipeline_state(ps_desc));","title":"Creating shader input layout and pipeline state"},{"location":"manual/introduction/getting_started/#creating-render-and-depth-textures","text":"The next step is to create the render texture and depth texture that is used as render target and depth stencil target. We also need to create render target view object and depth stencil view object for our render texture and depth texture. All graphic resources in Luna SDK, including buffers and textures, are described by ResourceDesc structure, and are represented by IResource interface. Here is the definition of the ResourceDesc structure: struct ResourceDesc { ResourceType type; ResourceHeapType heap_type; Format pixel_format; ResourceUsageFlag usages; u64 width_or_buffer_size; u32 height; u32 depth_or_array_size; u32 mip_levels; u32 sample_count; u32 sample_quality; ResourceFlag flags; }; type specifies the type of the resource, like buffer , texture_2d , etc. heap_type specifies which memory heap to create the resource in, possible options include: local - The resource can only be accessed by GPU, CPU access is disabled. This heap is suitable for GPU generated resources like temporary texture between render passes. shared and shared_upload - The resource can be accessed by both GPU and CPU, but is optimized for maximum GPU bandwidth, CPU access is slow and limited. shared_upload only allows CPU-write, while shared allows both CPU read and write. This heap is suitable for CPU-write-once textures like static textures read from file. upload - The resource can be written by CPU and read by GPU. This heap is suitable for resources that should be updated by CPU frequently. Textures cannot be created in this heap. readback - The resource can be written by GPU and read by CPU. This heap is suitable for transferring data from GPU to CPU frequently. Textures cannot be created in this heap. pixel_format specifies the pixel format of the resource if the resource is a texture, otherwise is ignored and will be set to unknown . usages specifies all possible roles of the resource when being bound to a pipeline. width_or_buffer_size , height and depth_or_array_size specifies the size of the resource, if the resource is a buffer, only width_or_buffer_size is used, and specifies the size of the buffer in bytes, otherwise, based on the type of the resource, those three properties specifies the width, height, depth (for 3D textures) or array size (for 1D and 2D textures) of the resource. mip_levels specifies the number of mips that should be allocated for the resource, if this is 0 , the system allocates full mipmap chain for the resource. sample_count and sample_quality specifies the sampling configuration for MSAA textures. flags specifies additional flags for the texture, like whether this texture can be simultaneously accessed by multiple command queues. To simplify the resource specification, we can use static methods provided by ResourceDesc to quickly construct ResourceDesc structure: ResourceDesc ResourceDesc::buffer(ResourceHeapType heap_type, ResourceUsageFlag usages, u64 size, ResourceFlag flags = ResourceFlag::none); ResourceDesc ResourceDesc::tex1d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u64 width, u32 array_size = 1, u32 mip_levels = 0, ResourceFlag flags = ResourceFlag::none); ResourceDesc ResourceDesc::tex2d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u32 width, u32 height, u32 array_size = 1, u32 mip_levels = 0, u32 sample_count = 1, u32 sample_quality = 0, ResourceFlag flags = ResourceFlag::none); ResourceDesc ResourceDesc::tex3d(ResourceHeapType heap_type, Format pixel_format, ResourceUsageFlag usages, u32 width, u32 height, u32 depth, u32 mip_levels = 0, ResourceFlag flags = ResourceFlag::none); Back to our DemoApp , we need to add four new properties to DemoApp to hold the render texture, the depth texture, and two views: Ref<RHI::IResource> rt_tex; Ref<RHI::IRenderTargetView> rtv; Ref<RHI::IResource> depth_tex; Ref<RHI::IDepthStencilView> dsv; Then we can create textures using the following code: auto window_size = window->get_framebuffer_size(); luset(rt_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, window_size.x, window_size.y, 1, 1))); luset(depth_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, window_size.x, window_size.y, 1, 1))); Note that when retrieving window size for rendering, we need to call IWindow::get_framebuffer_size instead of IWindow::get_size , on some platforms the window size is not necessary measured in pixels, causing these two methods return different values. We then need to create the render target view and depth stencil view for these two textures. Render target views and depth stencil views describes which portion of the texture will be bound to the graphic pipeline. Unlike other views, these two views are represented by dedicated objects: IRenderTargetView and IDepthStencilView , they can be created using the following code: luset(rtv, dev->new_render_target_view(rt_tex)); luset(dsv, dev->new_depth_stencil_view(depth_tex)); these two methods accepts additional RenderTargetViewDesc and DepthStencilViewDesc structures when creating views, but since we are using the default settings, these two structures can be omitted. Since we are using the window size as the render texture size, these textures should also be recreated when the window framebuffer is changed. This can be done by adding the following code to the DemoApp::resize method: luset(rt_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, width, height, 1, 1))); luset(depth_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, width, height, 1, 1))); luset(rtv, dev->new_render_target_view(rt_tex)); luset(dsv, dev->new_depth_stencil_view(depth_tex));","title":"Creating render and depth textures"},{"location":"manual/introduction/getting_started/#creating-buffers","text":"The next step is to create buffers used in our DemoApp , including: The vertex buffer and index buffer for our box mesh. The constant buffer for camera properties. Firstly we need to define the vertex structure of our box. Adding the following code after the declaration of DemoApp structure: struct Vertex { Float3U position; Float2U texcoord; }; Float2U and Float3U are vector types used in Luna SDK, which represent 2D and 3D vectors. In Luna SDK, we have 16-bytes aligned vector types Float2 , Float3 , Float4 , and unaligned vector types Float2U , Float3U and Float4U . The aligned vector types are used for calculations, SIMD functions like min , max , lerp , clamp only accepts aligned types, while unaligned vector types are used for storing and transferring data, such as in this case. The size of aligned vector types are all 16 bytes, while the size of unaligned types are 8, 12 and 16 for Float2U , Float3U and Float4U . We need to add three new properties to DemoApp to hold the these three buffers: Ref<RHI::IResource> vb; Ref<RHI::IResource> ib; Ref<RHI::IResource> cb; Then, we need to create the vertex buffer and index buffer for our box using the following code: Vertex vertices[] = { {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, +0.5, -0.5}, {0.0, 0.0}}, {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, -0.5, +0.5}, {1.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 1.0}}, {{+0.5, +0.5, +0.5}, {0.0, 0.0}}, {{-0.5, +0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 1.0}}, {{-0.5, -0.5, +0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}}, {{-0.5, +0.5, -0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}}, {{-0.5, -0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 0.0}}, {{+0.5, -0.5, -0.5}, {1.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}}, {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 1.0}}, {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}} }; u32 indices[] = { 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23 }; luset(vb, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::vertex_buffer, sizeof(vertices)))); luset(ib, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::index_buffer, sizeof(indices)))); void* mapped = nullptr; luexp(vb->map_subresource(0, false, &mapped)); memcpy(mapped, vertices, sizeof(vertices)); vb->unmap_subresource(0, true); luexp(ib->map_subresource(0, false, &mapped)); memcpy(mapped, indices, sizeof(indices)); ib->unmap_subresource(0, true); We firstly define vertex and index data for our box, then we create two buffer resources to hold the vertex and index data. Those two resources are created in shared_upload heap, so we can upload data to the resource, while still achieving maximum GPU bandwidth. After the resource is created, we can map the resource to system memory by calling IResource::map , and retrieving one pointer to the memory, then we use memcpy to copy buffer data, and use IResource::unmap to release the memory mapping, and store the data to the resource. We can use similar code to create the constant buffer for uploading camera properties, but there are two differences. First, the graphic device usually has alignment requirements for constant buffers, which can be fetched from IDevice::get_constant_buffer_data_alignment() , so we use align_upper helper function to adjust the size of our constant buffer resource to meet the alignment requirement. Second, since we need to update constant buffer data once every frame, we should choose upload heap instead of shared_upload for maximum CPU bandwidth. In our DemoApp , the data of the constant buffer is the 4x4 world-to-project matrix of the camera. We need to add a new include file to use matrix types: #include <Runtime/Math/Matrix.hpp> then we can use the following code to create constant buffer: auto cb_align = dev->get_constant_buffer_data_alignment(); luset(cb, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::upload, ResourceUsageFlag::constant_buffer, align_upper(sizeof(Float4x4), cb_align)))); as you can see, Float4x4 is the matrix type used in Luna SDK. We also have Float3x3 for 2D affine transformations.","title":"Creating buffers"},{"location":"manual/introduction/getting_started/#loading-image-from-file","text":"The next step is to load our Luna LOGO image that will be drawn on the box surface: Save the image file in the same directory as main.cpp , and naming it luna.png . You should have one file structure similar to this: DemoApp |- xmake.lua |- main.cpp |- luna.png Then fills xmake.lua with the following code: target(\"DemoApp\") set_luna_program() add_headerfiles(\"**.hpp\") add_files(\"**.cpp\") add_deps(\"Runtime\", \"Window\", \"RHI\", \"ShaderCompiler\", \"Image\") before_build(function(target) os.cp(\"$(scriptdir)/luna.png\", target:targetdir() .. \"/luna.png\") end) after_install(function (target) os.cp(target:targetdir() .. \"/luna.png\", target:installdir() .. \"/bin/luna.png\") end) target_end() This script triggers registers custom functions before building the program and after installing the program, the custom function copies the image file to same the directory of our program binary file, so that our program can correctly find the image file. We firstly need to add one new property to DemoApp to represent the loaded image: Ref<RHI::IResource> file_tex; To load the image in our program, we need to use one new module called Image , which parses image file data and gives row-majored image data in our desired format. We also need to use the file API provided by Runtime module, so we includes two new headers: #include <Runtime/File.hpp> #include <Image/Image.hpp> The first thing to do is to load image file data from our luna.png file. In order to load file data, we need to use the open_file function provided by the Runtime module. This function returns one file handle represented by IFile if the file is correctly opened. Then, we loads the file data into one Blob object by calling load_file_data , this function creates one properly-sized blob object, and calls IFile::read to read all data of the file to the blob, then returns the blob: lulet(image_file, open_file(\"Luna.png\", FileOpenFlag::read, FileCreationMode::open_existing)); lulet(image_file_data, load_file_data(image_file)); Now that the file data has been stored in image_file_data , we need to call Image::read_image_file function to parse the file data and gives the real image data: Image::ImageDesc image_desc; lulet(image_data, Image::read_image_file(image_file_data.data(), image_file_data.size(), Image::ImagePixelFormat::rgba8_unorm, image_desc)); Image::read_image_file function outputs one Image::ImageDesc structure that describes the returned image data, including the width, height and pixel format of the image. The image data is arranged in a row-major manner and without and alignment padding. We then creates one new resource, and uploads the data to the resource: luset(file_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::shared_upload, Format::rgba8_unorm, ResourceUsageFlag::shader_resource, image_desc.width, image_desc.height, 1, 1))); luexp(file_tex->map_subresource(0, false)); luexp(file_tex->write_subresource(0, image_data.data(), image_desc.width * Image::pixel_size(image_desc.format), image_desc.width * image_desc.height * Image::pixel_size(image_desc.format), BoxU(0, 0, 0, image_desc.width, image_desc.height, 1))); file_tex->unmap_subresource(0, true); Note that for texture resources, we cannot fetch pointers to the mapped data and copy data directly using memcpy like those in buffer resources. Instead, we need to call IResource::write_subresource after IResource::map_subresource to let the system copy data to the resource memory. The resource is created in shared_upload heap, which is the common option for resources whose data will be loaded from file.","title":"Loading image from file"},{"location":"manual/introduction/getting_started/#set-up-descriptor-set","text":"Once the constant buffer and file texture is set up, we can bind these two resources to the descriptor set that we need to bind to the pipeline state later. We also need to set the sampler in the descriptor set to be used by the pixel shader. desc_set->set_cbv(0, cb, ConstantBufferViewDesc(0, align_upper(sizeof(Float4x4), cb_align))); desc_set->set_srv(1, file_tex); desc_set->set_sampler(2, SamplerDesc(FilterMode::min_mag_mip_linear, TextureAddressMode::clamp, TextureAddressMode::clamp, TextureAddressMode::clamp, 0.0f, 1, ComparisonFunc::always, Float4U(0, 0, 0, 0), 0.0f, 0.0f)); This concludes the DemoApp::init function.","title":"Set up descriptor set"},{"location":"manual/introduction/getting_started/#camera-control","text":"Now that we have created all resources required to draw the box, we need to fill the actual drawing code in DemoApp::update . To make our program more interesting, we can apply one simple animation that rotates the camera around the box. We firstly adds one new property to DemoApp that stores the rotation angle of the camera: f32 camera_rotation = 0.0f; We can increase the rotation angle of the camera by one at every frame by adding the following line to the end of DemoApp:update : camera_rotation += 1.0f; Since we are going to use many functions that may throw errors, it is better to declare one lutry - lucatch scope that wraps all succeeding codes in DemoApp:update : RV DemoApp::update() { Window::poll_events(); if(window->is_closed()) return ok; lutry { camera_rotation += 1.0f; // More codes goes here... } lucatchret; return ok; } After we updates the camera rotation, we need to calculate the view-projection matrix for the camera. Fortunately, the math library of the Runtime module already includes implementations for many commonly used vector and matrix calculations, and here we are going to use two of them: AffineMatrix3D::make_look_at and perspective_projection_fov : Float3 camera_pos(cosf(camera_rotation / 180.0f * PI) * 2.0f, 1.0f, sinf(camera_rotation / 180.0f * PI) * 2.0f); Float4x4 camera_mat = AffineMatrix3D::make_look_at(camera_pos, Float3(0, 0, 0), Float3(0, 1, 0)); auto window_sz = window->get_framebuffer_size(); camera_mat = mul(camera_mat, perspective_projection_fov(PI / 3.0f, (f32)window_sz.x / (f32)window_sz.y, 0.001f, 100.0f)); The AffineMatrix3D namespace includes common functions for generating and decomposing 3D affine matrices. In our example, AffineMatrix3D::make_look_at generates one camera view matrix from the position of the camera and the position of the point to look at. perspective_projection_fov is another helper function that generates one projection matrix from the specified field-of-view and aspect ratio values. Those two matrices are multiplied by mul function to get the final view-projection matrix. Note that when performing matrix multiplications, use mul instead of operator * , the later one is used to multiply each element in the matrix separately. After we get the matrix, we can upload the matrix data to our constant buffer using the syntax similar to those for vertex and index buffers: void* camera_mapped; luexp(cb->map_subresource(0, false, &camera_mapped)); memcpy(camera_mapped, &camera_mat, sizeof(Float4x4)); cb->unmap_subresource(0, true);","title":"Camera control"},{"location":"manual/introduction/getting_started/#resource-barriers","text":"In Luna SDK, every graphic resource has one state that describes the current memory layout and pipeline access polity of the resource. Before we can issue draw calls, we need to transfer every resource we use to their correct states. Luna SDK requires the user to transfer the state explicitly by calling ICommandBuffer::resource_barriers with transition-typed resource barriers. In our example, we need to perform the following transitions: cmdbuf->resource_barriers({ ResourceBarrierDesc::as_transition(cb, ResourceState::vertex_and_constant_buffer), ResourceBarrierDesc::as_transition(vb, ResourceState::vertex_and_constant_buffer), ResourceBarrierDesc::as_transition(ib, ResourceState::index_buffer), ResourceBarrierDesc::as_transition(file_tex, ResourceState::shader_resource_pixel), ResourceBarrierDesc::as_transition(rt_tex, ResourceState::render_target), ResourceBarrierDesc::as_transition(depth_tex, ResourceState::depth_stencil_write) }); Luna SDK internally manages the current state for all resources, so we only need to specify the state of the resource after the transition. Luna SDK also omits unnecessary transitions automatically if the before and after state of one resource is same or compatible.","title":"Resource barriers"},{"location":"manual/introduction/getting_started/#drawing-the-box","text":"Finally, we can issue the draw call that draws our box: RenderPassDesc desc; desc.rtvs[0] = rtv; desc.rt_load_ops[0] = LoadOp::clear; desc.rt_store_ops[0] = StoreOp::store; desc.rt_clear_values[0] = {0, 0, 0, 0}; desc.dsv = dsv; desc.depth_load_op = LoadOp::clear; desc.depth_store_op = StoreOp::store; desc.depth_clear_value = 1.0f; desc.stencil_load_op = LoadOp::dont_care; desc.stencil_store_op = StoreOp::dont_care; cmdbuf->begin_render_pass(desc); cmdbuf->set_graphic_shader_input_layout(slayout); cmdbuf->set_pipeline_state(pso); cmdbuf->set_graphic_descriptor_set(0, desc_set); cmdbuf->set_primitive_topology(PrimitiveTopology::triangle_list); auto sz = vb->get_desc().width_or_buffer_size; cmdbuf->set_vertex_buffers(0, {VertexBufferViewDesc(vb, 0, sz, sizeof(Vertex))}); sz = ib->get_desc().width_or_buffer_size; cmdbuf->set_index_buffer(ib, 0, sz, Format::r32_uint); cmdbuf->set_scissor_rect(RectI(0, 0, (i32)window_sz.x, (i32)window_sz.y)); cmdbuf->set_viewport(Viewport(0.0f, 0.0f, (f32)window_sz.x, (f32)window_sz.y, 0.0f, 1.0f)); cmdbuf->draw_indexed(36, 0, 0); cmdbuf->end_render_pass(); The first thing to do is to begin a render pass that attaches one set of render targets and/or the depth stencil target to the graphic pipeline, these render resources are bound to the pipeline during the current render pass and cannot be changed, while all other settings (like shader input layout object, pipeline state object, descriptor sets, etc) can be changed within the same render pass. The render pass begins with ICommandBuffer::begin_render_pass . In the render pass, we set up all pipeline settings, and bind all resources required for the current draw call, then calls ICommandBuffer::draw_indexed to issue the draw call based on the current settings. Then we should close the render pass by calling ICommandBuffer::end_render_pass . We won't go detail about the pipeline setup for this draw call, they should be familiar to you if you have been using other graphics API before. For further explanations, please consult the documentations for the RHI module. As we have said before, commands in the command buffer will not be executed immediately, they should be submitted to the command queue explicitly to get executed. So we do it here: luexp(cmdbuf->submit()); This transfers the command buffer to the execution state, so we can no longer adding commands to the command buffer until we reset the command buffer using ICommandBuffer::reset .","title":"Drawing the box"},{"location":"manual/introduction/getting_started/#presenting-the-render-result","text":"The last thing is to present our rendering result to the window (or precisely, the back buffer in the window swap chain), and this is done by calling ISwapChain::presnet : luexp(swap_chain->present(rt_tex, 0, 1)); The first two parameters are the texture resource and subresource id to get displayed, and the system will blit the texture to the back buffer. For compatibility reasons, the user cannot fetch the back buffer directly like in other graphic APIs, this will bring one extra blit overhead on some platforms, but it won't be the bottleneck of your program for most cases. In Luna SDK, the present call is not synchronous, it only pushes the present command into the bounding command queue and returns directly. We should explicitly wait for the present command to be finished by calling ISwapChain::wait before we can start the next frame: swap_chain->wait(); Since we submitted the command buffer before the present call, when the present command is finished, the command buffer is guaranteed to be finished, so that we don't need to call cmdbuf->wait() explicitly and can reset the command buffer safely now: luexp(cmdbuf->reset()); This concludes the DemoApp::update function. Build and run DemoApp , if everything goes correctly, you will see a textured rotating box in the screen: Congratulations! If you have followed every step of this article correctly, you should have a first impression of graphic programming using Luna SDK. If anything goes wrong, you can compare your code with the following reference code to identify the mistake.","title":"Presenting the render result"},{"location":"manual/introduction/getting_started/#reference-code-for-maincpp","text":"#include <Runtime/Runtime.hpp> #include <Runtime/Module.hpp> #include <Runtime/Debug.hpp> #include <Window/Window.hpp> #include <RHI/RHI.hpp> #include <ShaderCompiler/ShaderCompiler.hpp> #include <RHI/ShaderCompileHelper.hpp> #include <Runtime/Math/Matrix.hpp> #include <Runtime/File.hpp> #include <Image/Image.hpp> #include <Runtime/Math/Transform.hpp> using namespace Luna; struct DemoApp { Ref<Window::IWindow> window; Ref<RHI::IDevice> dev; Ref<RHI::ICommandQueue> queue; Ref<RHI::ICommandBuffer> cmdbuf; Ref<RHI::ISwapChain> swap_chain; Ref<RHI::IDescriptorSetLayout> dlayout; Ref<RHI::IDescriptorSet> desc_set; Ref<RHI::IShaderInputLayout> slayout; Ref<RHI::IPipelineState> pso; Ref<RHI::IResource> rt_tex; Ref<RHI::IRenderTargetView> rtv; Ref<RHI::IResource> depth_tex; Ref<RHI::IDepthStencilView> dsv; Ref<RHI::IResource> vb; Ref<RHI::IResource> ib; Ref<RHI::IResource> cb; Ref<RHI::IResource> file_tex; f32 camera_rotation = 0.0f; RV init(); RV update(); bool is_exiting(); RV resize(u32 width, u32 height); }; DemoApp* g_app = nullptr; struct Vertex { Float3U position; Float2U texcoord; }; RV DemoApp::init() { lutry { luset(window, Window::new_window(\"DemoApp\", 0, 0, 0, 0, nullptr, Window::WindowCreationFlag::default_size | Window::WindowCreationFlag::position_center | Window::WindowCreationFlag::minimizable | Window::WindowCreationFlag::maximizable | Window::WindowCreationFlag::resizable)); window->get_close_event() += [](Window::IWindow* window) { window->close(); }; window->get_framebuffer_resize_event() += [](Window::IWindow* window, u32 width, u32 height) { lupanic_if_failed(g_app->resize(width, height)); }; dev = RHI::get_main_device(); using namespace RHI; luset(queue, dev->new_command_queue(CommandQueueType::graphic)); luset(cmdbuf, queue->new_command_buffer()); luset(swap_chain, new_swap_chain(queue, window, SwapChainDesc(0, 0, Format::rgba8_unorm, 2))); luset(dlayout, dev->new_descriptor_set_layout(DescriptorSetLayoutDesc({ {DescriptorType::cbv, 0, 1, ShaderVisibility::vertex}, {DescriptorType::srv, 1, 1, ShaderVisibility::pixel}, {DescriptorType::sampler, 2, 1, ShaderVisibility::pixel} }))); luset(desc_set, dev->new_descriptor_set(DescriptorSetDesc(dlayout))); const char vs_shader_code[] = R\"( cbuffer vertexBuffer : register(b0) { float4x4 world_to_proj; }; struct VS_INPUT { float3 position : POSITION; float2 texcoord : TEXCOORD; }; struct PS_INPUT { float4 position : SV_POSITION; float2 texcoord : TEXCOORD; }; PS_INPUT main(VS_INPUT input) { PS_INPUT output; output.position = mul(world_to_proj, float4(input.position, 1.0f)); output.texcoord = input.texcoord; return output; })\"; const char ps_shader_code[] = R\"( Texture2D tex : register(t1); SamplerState tex_sampler : register(s2); struct PS_INPUT { float4 position : SV_POSITION; float2 texcoord : TEXCOORD; }; float4 main(PS_INPUT input) : SV_Target { return float4(tex.Sample(tex_sampler, input.texcoord)); })\"; auto compiler = ShaderCompiler::new_compiler(); compiler->set_source({ vs_shader_code, strlen(vs_shader_code)}); compiler->set_source_name(\"DemoAppVS\"); compiler->set_entry_point(\"main\"); compiler->set_target_format(RHI::get_current_platform_shader_target_format()); compiler->set_shader_type(ShaderCompiler::ShaderType::vertex); compiler->set_shader_model(5, 0); compiler->set_optimization_level(ShaderCompiler::OptimizationLevel::full); luexp(compiler->compile()); auto vs_data = compiler->get_output(); Blob vs(vs_data.data(), vs_data.size()); compiler->reset(); compiler->set_source({ ps_shader_code, strlen(ps_shader_code)}); compiler->set_source_name(\"DemoAppPS\"); compiler->set_entry_point(\"main\"); compiler->set_target_format(RHI::get_current_platform_shader_target_format()); compiler->set_shader_type(ShaderCompiler::ShaderType::pixel); compiler->set_shader_model(5, 0); compiler->set_optimization_level(ShaderCompiler::OptimizationLevel::full); luexp(compiler->compile()); auto ps_data = compiler->get_output(); Blob ps(ps_data.data(), ps_data.size()); luset(slayout, dev->new_shader_input_layout(ShaderInputLayoutDesc({dlayout}, ShaderInputLayoutFlag::allow_input_assembler_input_layout | ShaderInputLayoutFlag::deny_hull_shader_access | ShaderInputLayoutFlag::deny_domain_shader_access | ShaderInputLayoutFlag::deny_geometry_shader_access))); GraphicPipelineStateDesc ps_desc; ps_desc.primitive_topology_type = PrimitiveTopologyType::triangle; ps_desc.sample_mask = U32_MAX; ps_desc.sample_quality = 0; ps_desc.blend_state = BlendDesc(false, false, { RenderTargetBlendDesc(false, false, BlendFactor::src_alpha, BlendFactor::inv_src_alpha, BlendOp::add, BlendFactor::inv_src_alpha, BlendFactor::zero, BlendOp::add, LogicOp::noop, ColorWriteMask::all) }); ps_desc.rasterizer_state = RasterizerDesc(FillMode::solid, CullMode::back, 0, 0.0f, 0.0f, 0, false, true, false, false, false); ps_desc.depth_stencil_state = DepthStencilDesc(true, true, ComparisonFunc::less_equal, false, 0x00, 0x00, DepthStencilOpDesc(), DepthStencilOpDesc()); ps_desc.ib_strip_cut_value = IndexBufferStripCutValue::disabled; ps_desc.input_layout = InputLayoutDesc({ {\"POSITION\", 0, Format::rgb32_float}, {\"TEXCOORD\", 0, Format::rg32_float}, }); ps_desc.vs = vs.cspan(); ps_desc.ps = ps.cspan(); ps_desc.shader_input_layout = slayout; ps_desc.num_render_targets = 1; ps_desc.rtv_formats[0] = Format::rgba8_unorm; ps_desc.dsv_format = Format::d32_float; luset(pso, dev->new_graphic_pipeline_state(ps_desc)); auto window_size = window->get_framebuffer_size(); luset(rt_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, window_size.x, window_size.y, 1, 1))); luset(depth_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, window_size.x, window_size.y, 1, 1))); luset(rtv, dev->new_render_target_view(rt_tex)); luset(dsv, dev->new_depth_stencil_view(depth_tex)); Vertex vertices[] = { {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, +0.5, -0.5}, {0.0, 0.0}}, {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, -0.5, +0.5}, {1.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 1.0}}, {{+0.5, +0.5, +0.5}, {0.0, 0.0}}, {{-0.5, +0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 1.0}}, {{-0.5, -0.5, +0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}}, {{-0.5, +0.5, -0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}}, {{-0.5, -0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 0.0}}, {{+0.5, -0.5, -0.5}, {1.0, 1.0}}, {{-0.5, +0.5, -0.5}, {0.0, 1.0}}, {{-0.5, +0.5, +0.5}, {0.0, 0.0}}, {{+0.5, +0.5, +0.5}, {1.0, 0.0}}, {{+0.5, +0.5, -0.5}, {1.0, 1.0}}, {{+0.5, -0.5, -0.5}, {0.0, 1.0}}, {{+0.5, -0.5, +0.5}, {0.0, 0.0}}, {{-0.5, -0.5, +0.5}, {1.0, 0.0}}, {{-0.5, -0.5, -0.5}, {1.0, 1.0}} }; u32 indices[] = { 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23 }; luset(vb, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::vertex_buffer, sizeof(vertices)))); luset(ib, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::shared_upload, ResourceUsageFlag::index_buffer, sizeof(indices)))); void* mapped = nullptr; luexp(vb->map_subresource(0, false, &mapped)); memcpy(mapped, vertices, sizeof(vertices)); vb->unmap_subresource(0, true); luexp(ib->map_subresource(0, false, &mapped)); memcpy(mapped, indices, sizeof(indices)); ib->unmap_subresource(0, true); auto cb_align = dev->get_constant_buffer_data_alignment(); luset(cb, dev->new_resource(ResourceDesc::buffer(ResourceHeapType::upload, ResourceUsageFlag::constant_buffer, align_upper(sizeof(Float4x4), cb_align)))); lulet(image_file, open_file(\"Luna.png\", FileOpenFlag::read, FileCreationMode::open_existing)); lulet(image_file_data, load_file_data(image_file)); Image::ImageDesc image_desc; lulet(image_data, Image::read_image_file(image_file_data.data(), image_file_data.size(), Image::ImagePixelFormat::rgba8_unorm, image_desc)); luset(file_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::shared_upload, Format::rgba8_unorm, ResourceUsageFlag::shader_resource, image_desc.width, image_desc.height, 1, 1))); luexp(file_tex->map_subresource(0, false)); luexp(file_tex->write_subresource(0, image_data.data(), image_desc.width * Image::pixel_size(image_desc.format), image_desc.width * image_desc.height * Image::pixel_size(image_desc.format), BoxU(0, 0, 0, image_desc.width, image_desc.height, 1))); file_tex->unmap_subresource(0, true); desc_set->set_cbv(0, cb, ConstantBufferViewDesc(0, align_upper(sizeof(Float4x4), cb_align))); desc_set->set_srv(1, file_tex); desc_set->set_sampler(2, SamplerDesc(FilterMode::min_mag_mip_linear, TextureAddressMode::clamp, TextureAddressMode::clamp, TextureAddressMode::clamp, 0.0f, 1, ComparisonFunc::always, Float4U(0, 0, 0, 0), 0.0f, 0.0f)); } lucatchret; return ok; } RV DemoApp::update() { Window::poll_events(); if(window->is_closed()) return ok; lutry { camera_rotation += 1.0f; Float3 camera_pos(cosf(camera_rotation / 180.0f * PI) * 2.0f, 1.0f, sinf(camera_rotation / 180.0f * PI) * 2.0f); Float4x4 camera_mat = AffineMatrix3D::make_look_at(camera_pos, Float3(0, 0, 0), Float3(0, 1, 0)); auto window_sz = window->get_framebuffer_size(); camera_mat = mul(camera_mat, perspective_projection_fov(PI / 3.0f, (f32)window_sz.x / (f32)window_sz.y, 0.001f, 100.0f)); void* camera_mapped; luexp(cb->map_subresource(0, false, &camera_mapped)); memcpy(camera_mapped, &camera_mat, sizeof(Float4x4)); cb->unmap_subresource(0, true); using namespace RHI; cmdbuf->resource_barriers({ ResourceBarrierDesc::as_transition(cb, ResourceState::vertex_and_constant_buffer), ResourceBarrierDesc::as_transition(vb, ResourceState::vertex_and_constant_buffer), ResourceBarrierDesc::as_transition(ib, ResourceState::index_buffer), ResourceBarrierDesc::as_transition(file_tex, ResourceState::shader_resource_pixel), ResourceBarrierDesc::as_transition(rt_tex, ResourceState::render_target), ResourceBarrierDesc::as_transition(depth_tex, ResourceState::depth_stencil_write) }); RenderPassDesc desc; desc.rtvs[0] = rtv; desc.rt_load_ops[0] = LoadOp::clear; desc.rt_store_ops[0] = StoreOp::store; desc.rt_clear_values[0] = {0, 0, 0, 0}; desc.dsv = dsv; desc.depth_load_op = LoadOp::clear; desc.depth_store_op = StoreOp::store; desc.depth_clear_value = 1.0f; desc.stencil_load_op = LoadOp::dont_care; desc.stencil_store_op = StoreOp::dont_care; cmdbuf->begin_render_pass(desc); cmdbuf->set_graphic_shader_input_layout(slayout); cmdbuf->set_pipeline_state(pso); cmdbuf->set_graphic_descriptor_set(0, desc_set); cmdbuf->set_primitive_topology(PrimitiveTopology::triangle_list); auto sz = vb->get_desc().width_or_buffer_size; cmdbuf->set_vertex_buffers(0, {VertexBufferViewDesc(vb, 0, sz, sizeof(Vertex))}); sz = ib->get_desc().width_or_buffer_size; cmdbuf->set_index_buffer(ib, 0, sz, Format::r32_uint); cmdbuf->set_scissor_rect(RectI(0, 0, (i32)window_sz.x, (i32)window_sz.y)); cmdbuf->set_viewport(Viewport(0.0f, 0.0f, (f32)window_sz.x, (f32)window_sz.y, 0.0f, 1.0f)); cmdbuf->draw_indexed(36, 0, 0); cmdbuf->end_render_pass(); luexp(cmdbuf->submit()); luexp(swap_chain->present(rt_tex, 0, 1)); swap_chain->wait(); luexp(cmdbuf->reset()); } lucatchret; return ok; } bool DemoApp::is_exiting() { return window->is_closed(); } RV DemoApp::resize(u32 width, u32 height) { lutry { using namespace RHI; auto dev = get_main_device(); luexp(swap_chain->resize_buffers(2, width, height, Format::rgba8_unorm)); luset(rt_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::rgba8_unorm, ResourceUsageFlag::shader_resource | ResourceUsageFlag::render_target, width, height, 1, 1))); luset(depth_tex, dev->new_resource(ResourceDesc::tex2d(ResourceHeapType::local, Format::d32_float, ResourceUsageFlag::depth_stencil, width, height, 1, 1))); luset(rtv, dev->new_render_target_view(rt_tex)); luset(dsv, dev->new_depth_stencil_view(depth_tex)); } lucatchret; return ok; } RV run_app() { auto result = init_modules(); if(failed(result)) return result; g_app = memnew<DemoApp>(); result = g_app->init(); if(failed(result)) return result; while(!g_app->is_exiting()) { result = g_app->update(); if(failed(result)) return result; } return ok; } int main() { bool initialized = Luna::init(); if(!initialized) return -1; RV result = run_app(); if(failed(result)) debug_printf(explain(result.errcode())); if(g_app) memdelete(g_app); Luna::close(); return 0; }","title":"Reference code for main.cpp"},{"location":"manual/introduction/getting_started/#reference-code-for-xmakelua","text":"target(\"DemoApp\") set_luna_program() add_headerfiles(\"**.hpp\") add_files(\"**.cpp\") add_deps(\"Runtime\", \"Window\", \"RHI\", \"ShaderCompiler\", \"Image\") before_build(function(target) os.cp(\"$(scriptdir)/luna.png\", target:targetdir() .. \"/luna.png\") end) after_install(function (target) os.cp(target:targetdir() .. \"/luna.png\", target:installdir() .. \"/bin/luna.png\") end) target_end()","title":"Reference code for xmake.lua"}]}